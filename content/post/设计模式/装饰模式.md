---
title: "装饰模式 (Decorator)"
date: 2021-12-10T16:29:53+08:00
draft: false
tags: [设计模式]
categories: [笔记] 
---

# 定义

装饰模式使用对象组合的方式动态改变或增加对象行为。

允许程序员通过将对象包装在「装饰器类的对象」中，在运行时动态更改对象的行为。

**何时使用**

在不想增加很多子类的情况下扩展类。

**Golang**

Go语言借助于匿名组合和非入侵式接口可以很方便实现装饰模式。

使用匿名组合，在装饰器中不必显式定义转调原对象方法。

# 样例

```go
package decorator

type Component interface {
	Calc() int
}

type ConcreteComponent struct{}

func (*ConcreteComponent) Calc() int {
	return 0
}

// MulDecorator 乘法装饰器
type MulDecorator struct {
	Component
	num int
}

func (d *MulDecorator) Calc() int {
	return d.Component.Calc() * d.num
}

func WarpMulDecorator(c Component, num int) Component {
	return &MulDecorator{
		c,
		num,
	}
}

// AddDecorator 加法装饰器
type AddDecorator struct {
	Component
	num int
}

func (d *AddDecorator) Calc() int {
	return d.Component.Calc() + d.num
}

func WarpAddDecorator(c Component, num int) Component {
	return &AddDecorator{
		Component: c,
		num:       num,
	}
}

```

测试

```go
package decorator

import (
	"fmt"
	"testing"
)

func TestDecorator(t *testing.T) {
	var c Component = &ConcreteComponent{}
	c = WarpAddDecorator(c, 10)
	c = WarpMulDecorator(c, 8)
	res := c.Calc()

	fmt.Printf("res: %d\n", res)
}

```

# 参考文献

1. https://github.com/kamranahmedse/design-patterns-for-humans
2. https://github.com/senghoo/golang-design-pattern

