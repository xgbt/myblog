---
title: "原型模式 (Prototype)"
date: 2021-12-05T16:29:53+08:00
draft: false
tags: [设计模式]
categories: [笔记] 
---

# 定义

简单说，创建现有对象的副本并根据需要对其进行修改。

原型模式配合原型管理器使用，使得客户端在不知道具体类的情况下，通过接口管理器得到新的实例，并且包含部分预设定配置。


**何时使用？**

当需要一个与现有对象相似的对象，或者与克隆相比，创建成本较高时，适合使用。



# 样例

```go
package prototype

// Cloneable 是原型对象需要实现的接口
type Cloneable interface {
	Clone() Cloneable
}

type Manager struct {
	prototypes map[string]Cloneable
}

func NewManager() *Manager {
	return &Manager{
		prototypes: make(map[string]Cloneable),
	}
}

func (m *Manager) Get(name string) Cloneable {
	// 不是直接返回m.prototypes[name]，而是返回他的Clone()
	return m.prototypes[name].Clone()
}

func (m *Manager) Set(name string, prototype Cloneable) {
	m.prototypes[name] = prototype
}

```

测试

```go
package prototype

import "testing"

var manager *Manager

type Type1 struct {
   name string
}

func (t *Type1) Clone() Cloneable {
   tc := *t
   return &tc
}

type Type2 struct {
   name string
}

func (t *Type2) Clone() Cloneable {
   tc := *t
   return &tc
}

func TestClone(t *testing.T) {
   t1 := manager.Get("t1")
   t2 := t1.Clone()
   if t1 == t2 {
      t.Fatal("error! get clone not working")
   }
}

func TestCloneFromManager(t *testing.T) {
   c := manager.Get("t1").Clone()
   t1 := c.(*Type1)
   if t1.name != "type1" {
      t.Fatal("error")
   }
}

func init() {
   manager = NewManager()
   t1 := &Type1{
      name: "type1",
   }
   manager.Set("t1", t1)
}
```

# 参考文献

1. https://github.com/kamranahmedse/design-patterns-for-humans
2. https://github.com/senghoo/golang-design-pattern

