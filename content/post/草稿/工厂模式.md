---
title: "工厂模式"
date: 2021-11-04T16:29:53+08:00
draft: false
tags: [设计模式]
categories: [笔记]
---

# 定义

请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。



# 样例1

![fig](/Factory1.jpg)

创建Animal接口

```java
public interface Animal {
    void speak();
    void preferredAction();
}
```

创建实体类Dog和Tiger继承Animal接口
```java
class Dog implements Animal {
    public void speak() {
        System.out.println("Dog says: Bow-Wow.");
    }

    public void preferredAction() {
        System.out.println("Dogs prefer barking...\n");
    }
}
```

```java
class Tiger implements Animal {
    public void speak() {
        System.out.println("Tiger says: Halum.");
    }

    public void preferredAction() {
        System.out.println("Tigers prefer hunting...\n");
    }
}
```
创建抽象工厂类Animal Factory
```java
abstract class AnimalFactory
{
    /*Remember that the GoF definition says "....Factory method lets a class defer instantiation to subclasses."
    In our case, the following method will create a Tiger or Dog but at this
    point it does not know whether it will get a Dog or a Tiger. This decision
    will be taken by the subclasses i.e. DogFactory or TigerFactory. So,in this
    implementation, the following method is playing the role of a factory (of
    creation)*/
    public abstract Animal createAnimal();
}
```

创建实体工厂类Dog Factory和Tiger Factory 实现Animal Factory

```java
public class DogFactory extends AnimalFactory {
    public Animal createAnimal () {
        // Creating a Dog
        return new Dog();
    }
}
```

```java
public class TigerFactory extends AnimalFactory {
    public Animal createAnimal() {
        // Creating a Tiger
        return new Tiger();
    }
}
```
编写测试样例
```java
public class FactoryMethodPatternExample {
    public static void main(String[] args) {
        System.out.println("***Factory Pattern Demo***\n");
        
        // Creating a Tiger Factory
        AnimalFactory tigerFactory = new TigerFactory();
        // Creating a tiger using the Factory Method
        Animal aTiger = tigerFactory.createAnimal();
        aTiger.speak();
        aTiger.preferredAction();

        // Creating a DogFactory
        AnimalFactory dogFactory = new DogFactory();
        // Creating a dog using the Factory Method
        Animal aDog = dogFactory.createAnimal();
        aDog.speak();
        aDog.preferredAction();
    }
}
```



## 输出

> Here’s the output.
>
> ***Factory Pattern Demo***
>
> Tiger says: Halum.
>
> Tigers prefer hunting...
>
> Dog says: Bow-Wow.
>
> Dogs prefer barking...



#  样例2

本例中，我们注意到Animal Factory类是一个抽象类。因此，利用抽象类的优势。

假设用户希望一个子类遵循其父类强加的规则。

其他实现和上例相通，主要修改抽象工厂类AnimalFactory。

```java
abstract class AnimalFactory
{
    public Animal makeAnimal() {
        System.out.println("I am inside makeAnimal() of AnimalFactory.You cannot ignore my rules.");
        /*At this point, it doesn't know whether it will get a Dog or a
        Tiger. It will be decided by the subclasses i.e.DogFactory or
        TigerFactory.But it knows that it will Speak and it will have a
        preferred way of Action.*/
        Animal animal = createAnimal();
        animal.speak();
        animal.preferredAction();
        return animal;
    }
    /*Remember that the GoF definition says "....Factory method lets a class
    defer instantiation to subclasses."
    In our case, the following method will create a Tiger or Dog but at this
    point it does not know whether it will get a Dog or a Tiger.
    This decision will be taken by the subclasses i.e. DogFactory or
    TigerFactory. So,in this implementation, the following method is playing
    the role of a factory (of creation)*/
    public abstract Animal createAnimal();
}
```

下面是新的demo，删掉了

```java
aDog.speak();
aDog.preferredAction();
```

```java
class ModifiedFactoryMethodPatternExample {
    public static void main(String[] args) {
        System.out.println("***Modified Factory Pattern Demo***\n");

        // Creating a Tiger Factory
        AnimalFactory tigerFactory = new TigerFactory();
        // Creating a tiger using the Factory Method
        Animal aTiger = tigerFactory.makeAnimal();

        // Creating a DogFactory
        AnimalFactory dogFactory = new DogFactory();
        // Creating a dog using the Factory Method
        Animal aDog = dogFactory.makeAnimal();

    }
}
```



## 输出

> ***Modified Factory Pattern Demo***
>
> I am inside makeAnimal() of AnimalFactory.You cannot ignore my rules.
>
> Tiger says: Halum.
>
> Tigers prefer hunting...
>
> I am inside makeAnimal() of AnimalFactory.You cannot ignore my rules.
>
> Dog says: Bow-Wow.
>
> Dogs prefer barking...

# 优点

- 将可能发生变化的代码与不会发生变化的代码分离开来，更方便程序员维护代码。
- 代码没有紧密耦合；因此可以随时在系统中添加新的类，如Lion、Beer等，而无需修改现有的体系结构。遵循了“修改是封闭的，扩展是开放的”原则。

# 缺点

- 如果需要处理大量的类，那么也需要创建更多的对应工厂类。

# 工厂模式与简单工厂模式

- 工厂模式的主要目的：提供了一个框架，通过这个框架，不同的子类可以制造不同的产品。

- 但简单工厂是一次性的。每当程序员想添加新内容时，需要在简单工厂模式的工厂类中添加一个if/else块或一个switch语句。

> 在简单工厂模式中，只需将实例化逻辑与客户机代码隔离。
>
> 在工厂模式中，它知道可以创建其对象的所有类。另一方面，当使用工厂方法模式时，您将对象创建委托给子类。另外，工厂方法并不能完全确定产品子类。

# 参考文献

1. Sarcar V. Java design patterns[M]. Apress, 2016.

