---
title: "中介者模式"
date: 2021-11-21T16:29:53+08:00
draft: false
tags: [设计模式]
categories: [笔记]
---

# 定义

定义一个对象来封装一组对象的交互方式。中介者模式通过避免对象显式地相互引用来促进低耦合，并且它允许您独立地改变它们的交互。



中介模式的整体结构如下图所示。

![fig](/Mediator.jpg)

具体来说：

- Mediator：提供Colleague对象之间通信的接口。
- ConcreteMediator：维护Colleague对象的列表。实现了Mediator接口并协调Colleague对象之间的通信。
- Colleague：Colleague接口，定义Colleague如何与其他Colleague进行通信。
- ConcreteColleague1 & ConcreteColleague2：实现Colleague接口。这些对象通过Mediator相互通信。

# 样例1

类图如下：

![fig](/Mediator1.jpg)

首先是Mediator接口，注意Mediator的方法参数包括了可能会使用这个中介的Employee

```java
public interface Mediator {
    void register(Employee employee);
    void sendMessage(Employee employee, String msg) throws InterruptedException;
}
```

然后实现该接口，该Mediator用一个链表维护所有员工

```java
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

public class ConcreteMediator implements Mediator {
    List<Employee> participants = new ArrayList<Employee>();

    @Override
    public void register(Employee employee) {
        participants.add(employee);
    }

    @Override
    public void sendMessage(Employee employee, String msg) throws InterruptedException {
        if (participants.contains(employee)) {
            System.out.println(employee.getName() + " posts:" + msg + "Last  message posted at " + LocalDateTime.now());
            Thread.sleep(1000);
        } else {
            System.out.println("An outsider named " + employee.getName() + "  is trying to send some messages.");
        }
    }

    public void displayRegisteredEmployees()
    {
        System.out.println("At present,registered employees are:");
        for (Employee employee: participants)
        {
            System.out.println(employee.getName());
        }
    }
}
```

然后是Employee抽象类

```java
abstract class Employee {
    protected Mediator mediator;
    protected String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Employee(Mediator mediator) {
        this.mediator = mediator;
    }

    public void sendMessage(String msg) throws InterruptedException {
        mediator.sendMessage(this, msg);
    }

    public abstract String employeeType();
}
```

三个类分别继承Employee

```java
public class JuniorEmployee extends Employee {
    public JuniorEmployee(Mediator mediator, String name) {
        super(mediator);
        this.name = name;
    }

    @Override
    public String employeeType() {
        return "JuniorEmployee";
    }

}
```

```java
public class SeniorEmployee extends Employee {
    public SeniorEmployee(Mediator mediator, String name) {
        super(mediator);
        this.name = name;
    }

    @Override
    public String employeeType() {
        return "SeniorEmployee";
    }
}
```

```java
public class Unknown extends Employee {
    public Unknown(Mediator mediator, String name) {
        super(mediator);
        this.name = name;
    }

    @Override
    public String employeeType() {
        return "Unknown";
    }
}
```

最后是测试类。

注意，只有注册的用户才能相互通信并在聊天服务器上成功发布消息。Mediator不允许任何外人进入系统。

```java
public class MediatorPatternExample {
    public static void main(String[] args) throws InterruptedException {
        System.out.println("***Mediator Pattern Demo***\n");

        ConcreteMediator mediator = new ConcreteMediator();
        JuniorEmployee amit = new JuniorEmployee(mediator, "Amit");
        JuniorEmployee sohel = new JuniorEmployee(mediator, "Sohel");
        SeniorEmployee raghu = new SeniorEmployee(mediator, "Raghu");

        //Registering participants
        mediator.register(amit);
        mediator.register(sohel);
        mediator.register(raghu);
        //Displaying the participant's list
        mediator.displayRegisteredEmployees();

        System.out.println("Communication starts among participants...");
        amit.sendMessage("Hi Sohel,can we discuss the mediator pattern?");
        sohel.sendMessage("Hi Amit,yup, we can discuss now.");
        raghu.sendMessage("Please get back to work quickly.");
        //An outsider/unknown person tries to participate
        Unknown unknown = new Unknown(mediator, "Jack");
        unknown.sendMessage("Hello Guys..");
    }
}
```

## 输出

> ***Mediator Pattern Demo***
>
> At present,registered employees are:
>
> Amit
>
> Sohel
>
> Raghu
>
> Communication starts among participants...
>
> Amit posts:Hi Sohel,can we discuss the mediator pattern?Last  message posted at 2021-12-16T23:01:46.234535
>
> Sohel posts:Hi Amit,yup, we can discuss now.Last  message posted at 2021-12-16T23:01:47.250810700
>
> Raghu posts:Please get back to work quickly.Last  message posted at 2021-12-16T23:01:48.255648900
>
> An outsider named Jack  is trying to send some messages.



#  样例2

样例1是一个简单的样例，但还可以进一步改进。

- 消息只在一个方向上传递。

- 当一个参与者发布消息时，每个人都可以看到该消息。所以，这里没有隐私。

- 如果员工忘记注册自己，他是不允许发送信息的。这很好，但他不应该被当作外来者对待。在正常情况下，应该区别对待组织外部人员和忘记在服务器上注册自己的组织雇员。

- 客户端代码需要将参与者注册到中介。

  比如` JuniorEmployee amit = new JuniorEmployee(mediator, "Amit");`

  虽然有人可能认为这不是一个缺点，但其实可以选择一种更好的方法。例如，当程序员在客户端代码中创建Employee对象时，可以将参与者自动注册到中介。

- 程序员没有在客户端代码中使用`employeeType()`方法。

所以根据上述几点，修改样例1，以下是几个修改的要点。

- `JunioreEmployee`和`SenioreEmployee`类被替换为单个的`ConcreteEmployee`类。它帮助我们轻松地识别谁属于组织，谁不属于组织。

- 在修改后的实现中，每个参与者都可以看到谁正在发布消息，但不公开它的目标是谁或实际的消息是什么。所以，两个参与者之间是有隐私的。

- 在客户端代码中，创建如下所示的参与者。
  `Employee Amit = new ConcreteEmployee(mediator, "Amit", true);`

  第三个参数(true/false)用于确定员工是否想要将自己注册到中介。当他试图发布信息时，会因此受到不同的对待。

- `employeeType()`方法确定参与者是来自组织内部还是外部。

  `if( fromEmployee.employeeType()=="UnauthorizedUser")`



然后开始实现

首先是Mediator的接口

```java
public interface Mediator {
    void register(Employee employee);

    void sendMessage(Employee fromEmployee, Employee toEmployee, String msg) throws InterruptedException;
}
```

然后实现该接口，具体来说用一个链表维护所有员工；发送消息时，会判断员工的雇员类型，并据此进行不同的操作。

```java
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

public class ConcreteMediator implements Mediator {
    List<Employee> participants = new ArrayList<Employee>();

    @Override
    public void register(Employee employee) {
        participants.add(employee);
    }

    @Override
    public void sendMessage(Employee fromEmployee, Employee toEmployee, String msg) throws InterruptedException {
        /*if( fromEmployee.getClass().getSimpleName().equals("UnauthorizedUser"))*/
        if (fromEmployee.employeeType() == "UnauthorizedUser") {
            System.out.println("[ALERT Everyone] An outsider named " +
                    fromEmployee.getName() + " trying to send some messages to " + toEmployee.getName());
            fromEmployee.receive(fromEmployee, ",you are not allowed to enter here.");
        } else if (participants.contains(fromEmployee)) {
            System.out.println("-----" + fromEmployee.getName() + " posts some message at: " + LocalDateTime.now() + "-----");
            Thread.sleep(1000);
            //No need to inform everyone or himself
            //Only let the target receiver know
            if (participants.contains(toEmployee)) {
                toEmployee.receive(fromEmployee, msg);
            }
            //If target receipient does not exist
            else {
                System.out.println(fromEmployee.getName() + " , your target recipient does not exist");
            }
        }
        //An outsider tries to send message.
        else {
            System.out.println("[ALERT] An unregistered employee named " +
                    fromEmployee.getName() + " trying to send some messages to " + toEmployee.getName());
            System.out.println(fromEmployee.getName() + ", you need to  register yourself first.");
        }
    }

    public void displayRegisteredEmployees() {
        System.out.println("At present ,registered participants are:");
        for (Employee employee : participants) {
            System.out.println(employee.getName());
        }
    }
}
```

然后是雇员抽象类

```java
public abstract class Employee {
    private final Mediator mediator;
    private final boolean authorizedUser;
    protected String name;

    public Employee(Mediator mediator, String name, boolean authorizedUser) {
        this.mediator = mediator;
        this.name = name;
        this.authorizedUser = authorizedUser;
        if (authorizedUser) {
            mediator.register(this);
        }
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    //The following method name need not be same as the Mediator's method name
    public void send(Employee toFriend, String msg) throws InterruptedException {
        mediator.sendMessage(this, toFriend, msg);
    }

    public void receive(Employee fromFriend, String msg) {
        System.out.println(this.name + " received a message : " + msg + " from an employee " + fromFriend.getName() + ".");
    }

    public abstract String employeeType();

}
```

分别实现雇员抽象类

```java
public class ConcreteEmployee extends Employee {

    public ConcreteEmployee(Mediator mediator, String name, boolean authorizedUser) {
        super(mediator, name, authorizedUser);
    }

    @Override
    public String employeeType() {
        return "ConcreteEmployee";
    }
}

```

```java
public class UnauthorizedUser extends Employee{
    
    public UnauthorizedUser(Mediator mediator, String name)
    {
        //The user is always treated an unauthorized user.So, the flag is
        //false always.
        super(mediator,name, false);
    }

    @Override
    public void receive(Employee fromEmployee,String message) {
        System.out.println(this.name + message);
    }

    @Override
    public String employeeType()
    {
        return "UnauthorizedUser";
    }
}
```

然后测试类

```java
public class MediatorPatternExample {
    public static void main(String[] args) throws InterruptedException {
        System.out.println("***Mediator Pattern Demo***\n");
        
        ConcreteMediator mediator = new ConcreteMediator();
        Employee Amit = new ConcreteEmployee(mediator, "Amit", true);
        Employee Sohel = new ConcreteEmployee(mediator, "Sohel", true);
        Employee Raghu = new ConcreteEmployee(mediator, "Raghu", true);
        //Unauthorized user
        Employee Jack = new ConcreteEmployee(mediator, "Jack", false);
        //Only two parameter needed to pass in the following case.
        Employee Divya = new UnauthorizedUser(mediator, "Divya");
        //Displaying the participant's list
        mediator.displayRegisteredEmployees();
        
        System.out.println("Communication starts among participants...");
        Amit.send(Sohel, "Hi Sohel,can we discuss the mediator pattern?");
        Sohel.send(Amit, "Hi Amit,Yup, we can discuss now.");
        
        //Boss is sending messages to each of them individually
        Raghu.send(Amit, "Please get back to work quickly.");
        Raghu.send(Sohel, "Please get back to work quickly.");
        
        //An unregistered employee(Jack) and an outsider(Divya) are also
        //trying to participate.
        Jack.send(Amit, "Hello Guys..");
        Divya.send(Raghu, "Hi Raghu");
    }
}
```

## 输出

> ***Mediator Pattern Demo***
>
> At present ,registered participants are:
>
> Amit
>
> Sohel
>
> Raghu
>
> Communication starts among participants...
>
> -----Amit posts some message at: 2021-12-17T14:19:35.869492100-----
>
> Sohel received a message : Hi Sohel,can we discuss the mediator pattern? from an employee Amit.
>
> -----Sohel posts some message at: 2021-12-17T14:19:36.889175-----
>
> Amit received a message : Hi Amit,Yup, we can discuss now. from an employee Sohel.
>
> -----Raghu posts some message at: 2021-12-17T14:19:37.901422-----
>
> Amit received a message : Please get back to work quickly. from an employee Raghu.
>
> -----Raghu posts some message at: 2021-12-17T14:19:38.905317900-----
>
> Sohel received a message : Please get back to work quickly. from an employee Raghu.
>
> [ALERT] An unregistered employee named Jack trying to send some messages to Amit
>
> Jack, you need to  register yourself first.
>
> [ALERT Everyone] An outsider named Divya trying to send some messages to Raghu
>
> Divya,you are not allowed to enter here.

# 优点

- 降低系统中对象之间通信的复杂性。
- 中介者模式促进松耦合。
- 有效减少代码中子类的数量。
- 将「多对多」关系替换为「一对多关系」，提高代码的可读性

# 缺点

- 在某些情况下，难以实现合适的封装
- 如果Mediator对象放入太多逻辑，可能导致体系结构过于复杂。有可能导致「God Class」反模式。

# 中介者模式与外观模式

可以将中介者模式描述为一个多路的外观模式，在中介者模式中，不采用单一对象的接口，而是在多个对象之间创建多路接口，以提供平滑的转换。



# 参考文献

1. Sarcar V. Java design patterns[M]. Apress, 2016.

