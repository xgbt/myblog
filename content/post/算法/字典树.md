---
title: "字典树问题"
date: 2021-12-28T14:31:05+08:00
draft: false
tags: [算法]
categories: [笔记]
---



# 472. 连接词

给你一个 不含重复 单词的字符串数组 words ，请你找出并返回 words 中的所有 连接词 。

连接词 定义为：一个完全由给定数组中的至少两个较短单词组成的字符串。

- 方法：字典树 + 深度优先搜索
  判断一个单词是不是连接词，需要判断这个单词是否完全由至少两个给定数组中的更短的非空单词（可以重复）组成。判断更短的单词是否在给定数组中，可以使用字典树实现。
- 首先，将数组 word 按照字符串的长度排序，确保当遍历到任意单词时，比该单词短的单词一定都已经遍历过，因此可以根据已经遍历过的全部单词判断当前单词是不是连接词。
- 然后，遍历 word ，对于每个非空单词，判断该单词是不是连接词，如果是连接词则将该单词加入ans，如果不是连接词则将该单词加入字典树。

```go
// 字典树结构体
type trie struct {
    next [26] *trie
    isEnd bool
}

// 字典树插入操作
func (root *trie) Insert(word string) {
    node := root
    for _, ch := range word {
        ch -= 'a'
        if node.next[ch] == nil {
            node.next[ch] = &trie{}
        }
        node = node.next[ch]
    }
    node.isEnd = true
}

// 在字典树上进行深度优先搜索
func (root *trie) dfs(word string) bool {
    // 如果word已经搜索正好为空，说明已经匹配完毕，
    if (word == "") {
        return true
    }

    // 从字典树头开始匹配
    node := root
    for i, ch := range word {
        node = node.next[ch - 'a']
        // 若该单词不存在与字典树中，说明匹配失败
        if node == nil {
            return false
        }
        // 若当前单词已经匹配完毕，且接下来的单词也匹配成功，则返回true
        if node.isEnd && root.dfs(word[i + 1:]) {
            return true
        } 
    }
    
    return false
}

func findAllConcatenatedWordsInADict(words []string) (ans []string) {
    // 按照word长度从小到大排序
    sort.Slice(words, func(i, j int) bool {
        return len(words[i]) < len(words[j])
    })

    root := &trie{}

    // 遍历所有word
    for _, word := range(words) {
        // 如果word为空，跳过
        if word == "" {
            continue;
        }
        // 如果word匹配成功，加入ans
        if root.dfs(word) {
            ans = append(ans, word)
        } else {
            // 否则加入字典树中 
            root.Insert(word)
        }
    }

    return ans
}
```



