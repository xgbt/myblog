---
title: "多路归并问题"
date: 2022-01-13T14:31:05+08:00
draft: false
tags: [算法]
categories: [笔记]
---

# 373. 查找和最小的 K 对数字

给定两个以 升序排列 的整数数组 nums1 和 nums2 , 以及一个整数 k 。

定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2 。

请找到和最小的 k 个数对 (u1,v1),  (u2,v2)  ...  (uk,vk) 。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



- 优先队列，利用题目中两数组均为升序的性质，构建结构体存储每队数字的下标和值。
- 首先存储所有[0,0]到[n - 1, 0]的数对如优先队列中，然后逐次取出，每次取出判断当前取出的这个[x,y]，y能否再往后移动一位，如果可以的话就把[x, y + 1] 存入优先队列。

```c++
class Solution {
public:
    struct Node {
        int i, j, x, y;
        bool operator <(const Node obj) const {
            return x + y > obj.x + obj.y;
        }
        Node (int i, int j, int x, int y) {
            this->i = i;
            this->j = j;
            this->x = x;
            this->y = y;
        }
    };

    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {
        vector<vector<int>> ans;
        int n = nums1.size();
        int m = nums2.size();
        priority_queue <Node> pq;

        for (int i = 0; i < n && i < k; i++) {
            pq.push(Node{i, 0, nums1[i], nums2[0]});
        }

        while (k-- && !pq.empty()) {
            Node cur = pq.top();
            pq.pop();
            ans.push_back({cur.x, cur.y});
            if (cur.j + 1 < m) {
                cur.y = nums2[++cur.j];
                pq.push(cur);
            }
        }

        return ans;
    }
};
```

# 786. 第 K 个最小的素数分数

给你一个按递增顺序排序的数组 arr 和一个整数 k 。数组 arr 由 1 和若干 素数  组成，且其中所有整数互不相同。

对于每对满足 0 <= i < j < arr.length 的 i 和 j ，可以得到分数 arr[i] / arr[j] 。

那么第 k 个最小的分数是多少呢?  以长度为 2 的整数数组返回你的答案, 这里 answer[0] == arr[i] 且 answer[1] == arr[j] 。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/k-th-smallest-prime-fraction
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



- 思路同上，先将a[0]/a[1]到a[0]/a[n-1]扔到优先队列中，这样相当于存储了各种分母的最小项，然后每次取出最小项，接下俩判断分子下标是否能在再+1，若能，则加完之后扔回优先队列。

```c++
class Solution {
public:
    struct Node {
        int i, j;
        double res;
        bool operator <(const Node obj) const {
            return res > obj.res;
        }
        Node (int i, int j, double res) {
            this->i = i;
            this->j = j;
            this->res = res;
        }
    };

    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {
        int n = arr.size();
        vector <int> ans;
        priority_queue <Node> pq;

        for (int i = n - 1; i >= 1 && n - 1 - i <= k; i--) {
            pq.push(Node{0, i, (double)arr[0] / arr[i]});
        }

        while (k-- && !pq.empty()) {
            Node cur = pq.top();
            pq.pop();

            if (k == 0) {
                ans.push_back(arr[cur.i]);
                ans.push_back(arr[cur.j]);
                break;
            }

            if (cur.i + 1 < n && cur.i + 1 != cur.j) {
                cur.res = (double) arr[++cur.i] / arr[cur.j];
                pq.push(cur);
            }
        }

        return ans;
    }
};
```



# 632. 最小区间

你有 k 个 非递减排列 的整数列表。找到一个 最小 区间，使得 k 个列表中的每个列表至少有一个数包含在其中。

我们定义如果 b-a < d-c 或者在 b-a == d-c 时 a < c，则区间 [a,b] 比 [c,d] 小。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

- 先队列始终会有k个元素，维护k个数组中各个数组的最小元素
- 同时维护所有k个数组中最大的元素
- 每次从优先队列取出元素时，更新答案区间，直到某一数字的数字全部用完为止。

```cpp
class Solution {
public:
    struct Node {
        int grp, idx, val;
        bool operator <(const Node obj) const {
            return val > obj.val;
        }
    };

    vector<int> smallestRange(vector<vector<int>>& nums) {
        int k = nums.size();
        int L = -1e5, R = 1e5;

        // 优先队列始终会有k个元素，维护k个数组中各个数组的最小元素
        priority_queue <Node> pq;
        // 维护所有k个数组中最大的元素
        int imax = INT_MIN;
        for (int i = 0; i < k; i++) {
            pq.push({i, 0, nums[i][0]});
            imax = max(imax, nums[i][0]);
        }

        while (1) {
            Node cur = pq.top();
            pq.pop();

            if (imax - cur.val < R - L) {
                R = imax;
                L = cur.val;
            }

            if (cur.idx + 1 < nums[cur.grp].size()) {
                cur.val = nums[cur.grp][++cur.idx];
                pq.push(cur);
                imax = max(imax, cur.val);
            } 
            else {
                break;
            }
        }

        return {L, R};
    }
};
```
