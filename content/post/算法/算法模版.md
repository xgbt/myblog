---
title: "算法模版"
date: 2022-02-28T21:31:05+08:00
draft: false
tags: [专业知识]
categories: [笔记]
---

# 拓扑排序
# 位运算

`__builtin_popcount(x)` 求x二进制下有多少个1



# vector

## 在首尾插入元素

`v.insert(v.begin(), num);`

`v.push_back(num);`

# map

## 判断元素x是否存在

`if (mp.count(x)) `

`if (mp.find(x) != mp.end())`





# 技巧

## 二分

在排序数组中查找某元素的第一个和最后一个位置

lower_bound, 查找符合条件的第一个元素(**左边界**)

查找符合条件的最后一个元素，实际上就是upper_bound - 1(**右边界**)，因为有-1，所以除了判断l - 1 < n，还要判断l - 1 >= 0

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        vector <int> ans;
        int n = nums.size();
        int l, r;

        l = 0, r = n;
        while (l < r) {
            int mid = l + (r - l) / 2;
            if (nums[mid] >= target) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        if (l < n && nums[l] == target) {
            ans.push_back(l);
        } else {
            ans.push_back(-1);
        }

        l = 0, r = n;
        while (l < r) {
            int mid = l + (r - l) / 2;
            if (nums[mid] > target) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        if (l - 1 < n && l - 1 >= 0 && nums[l - 1] == target) {
            ans.push_back(l - 1);
        } else {
            ans.push_back(-1);
        }

        return ans;
    }
};
```

## 快速幂

```c++
double quickPow(double base, long long exp) {
    if (exp < 0) {
        base = 1 / base;
        exp = -exp;
    }
    
    double ans = 1;
    while (exp) {
        if (exp % 2 == 1) {
            ans *= base;
            exp -= 1;
        } else {
            base *= base;
            exp /= 2;
        }
    }
    
    return ans;
}
```

## 结构体操作

```c++
struct Node {
    int idx, val, mapped;
    //构造函数
    Node(int idx, int val, int mapped): idx(idx), val(val), mapped(mapped){}
	//自定义比较符
    bool operator<(const Node obj)const {
        if (mapped == obj.mapped) {
            return idx < obj.idx;
        }
        return mapped < obj.mapped;
    }
};
```





## 字符串转数字

`int stoi(str)`

`long stol(str)`

`float stof(str)`

`double stod(str)`

## 数字转字符串

`string to_string(num)`

## gcd

## lcm

## 图论

dfs

bfs

floyd算法

dijkstra算法

拓扑排序

## 邻接表构图

```c++
const int maxn = 1005;
const int maxm = maxn * maxn / 2;

struct Edge {
    int to, next;
}e[maxm];

int head[maxn];
int num = 0;
bool vis[maxn];

void init() {
    memset(vis, 0, sizeof(vis));
    memset(head, -1, sizeof(head));
}

void add(int from, int to) {
    e[num].to = to;
    e[num].next = head[from];
    head[from] = num++;
}

```



