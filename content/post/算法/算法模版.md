---
title: "算法模版"
date: 2022-02-28T21:31:05+08:00
draft: false
tags: [专业知识]
categories: [笔记]
---



# 位运算





# 数据结构

## vector

### 首部插入元素

```c++
v.insert(v.begin(), num);
```

### 尾部插入元素

```c++
v.push_back(num);
```







## map

### 删除某元素

```c++
mp.earse(x)
```

### 判断元素x是否存在

```c++
mp.count(x) // 存在返回1，不存在返回0
```

或者

```c++
if (mp.find(x) != mp.end())
```





### 遍历map中的元素(unordered_map与map)

注意，以下两种方式只适合map遍历，因为map基于红黑树实现，内部数据是有序的。

不适合unordered_map遍历，因为u_map是基于哈希表实现的，内部数据是无序的

```c++
for (auto& [_, cnt]: mp) {
    imax += cnt;
    ans = max(ans, imax);
}
```

```c++
for (auto& it: mp) {
    imax += it.second;
    ans = max(ans, imax);
}
```

![img](https://pic1.zhimg.com/80/v2-e7a0e37ae8457359287f99f9859dda28_720w.jpg)



# 技巧

## 判断质数

```c++
bool isPrime(int x) {
        if (x < 2) {
            return false;
        }
        for (int i = 2; i * i <= x; ++i) {
            if (x % i == 0) {
                return false;
            }
        }
        return true;
    }
```

统计1-n质数数量

```c++
int primes(int n) {
    bool is[105];
    memset(is, true, sizeof(is));

    for (int i = 2; i * i <= n; i++) {
        if (is[i]) {
            for (int j = i * i; j <= n; j += i) {
                is[j] = false;
            } 
        }
    }

    int ret = 0;
    for (int i = 2; i <= n; i++) {
        if (is[i]) {
            ret++;
        }
    }

    return ret;
}
```





## C++ 浮点数比较

```c++
const double EPS = 1e-6;

// 0 =, 1 >, -1 <
int dcmp(double x, double y)
{
    if(fabs(x - y) < eps){
        return 0;
    } else {
        return fabs(x - y) > 0 ? 1 : -1;
    }
}
```

## 二分

在排序数组中查找某元素的第一个和最后一个位置

lower_bound, 查找符合条件的第一个元素(**左边界**)

查找符合条件的最后一个元素，实际上就是upper_bound - 1(**右边界**)，因为有-1，所以除了判断l - 1 < n，还要判断l - 1 >= 0

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        vector <int> ans;
        int n = nums.size();
        int l, r;

        l = 0, r = n;
        while (l < r) {
            int mid = l + (r - l) / 2;
            if (nums[mid] >= target) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        if (l < n && nums[l] == target) {
            ans.push_back(l);
        } else {
            ans.push_back(-1);
        }

        l = 0, r = n;
        while (l < r) {
            int mid = l + (r - l) / 2;
            if (nums[mid] > target) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        if (l - 1 < n && l - 1 >= 0 && nums[l - 1] == target) {
            ans.push_back(l - 1);
        } else {
            ans.push_back(-1);
        }

        return ans;
    }
};
```

## 快速幂

```c++
double quickPow(double base, long long exp) {
    if (exp < 0) {
        base = 1 / base;
        exp = -exp;
    }
    
    double ans = 1;
    while (exp) {
        if (exp % 2 == 1) {
            ans *= base;
            exp -= 1;
        } else {
            base *= base;
            exp /= 2;
        }
    }
    
    return ans;
}
```

## 结构体操作

```c++
struct Node {
    int idx, val, mapped;
    //构造函数
    Node(int idx, int val, int mapped): idx(idx), val(val), mapped(mapped){}
	//自定义比较符
    bool operator<(const Node obj)const {
        if (mapped == obj.mapped) {
            return idx < obj.idx;
        }
        return mapped < obj.mapped;
    }
};
```



# 树

## 字典树

例题：https://leetcode.cn/problems/replace-words/ 模版替换

```c++
// 字典树数据结构
struct Trie {
    unordered_map <char, Trie*> mp;
};

class Solution {
public:
    string replaceWords(vector<string>& dictionary, string sentence) {
        // 构建字典树
        Trie* trie = new Trie();
        for (auto& word: dictionary) {
            auto cur = trie;
            for (char& ch : word) {
                if (!cur->mp.count(ch)) {
                    cur->mp[ch] = new Trie();
                }
                cur = cur->mp[ch];
            }
            cur->mp['#'] = new Trie();
        }

        vector <string> words = split(sentence, ' ');
        for (auto& word : words) {
            word = findRoot(word, trie);
        }
		
        string ans;
        for (int i = 0; i < words.size() - 1; i++) {
            ans += words[i] + " ";
        }
        ans += words.back();

        return ans;
    }

    vector<string> split(string str, char ch) {
        ...
    }
	// 跟根据字典树返回词根
    string findRoot(string& word, Trie* trie) {
        string root;
        auto cur = trie;
        for (char ch : word) {
            if (cur->mp.count('#')) {
                return root;
            } else if (!cur->mp.count(ch)) {
                return word;
            } else {
                root.push_back(ch);
                cur = cur->mp[ch];
            }
        }

        return root;
    }
};
```







# 字符串

## C++手动实现Split

```C++
vector<string> split(string str, char ch) {
    int pos = 0;
    int start = 0;
    vector<string> ret;

    while (pos < str.size()) {
        while (pos < str.size() && str[pos] == ch) {
            pos++;
        }
        start = pos;
        while (pos < str.size() && str[pos] != ch) {
            pos++;
        }
        if (start < str.size()) {
            ret.emplace_back(str.substr(start, pos - start));
        }
    }

    return ret;
}
```



## 使用stringstream解析字符串

```c++
class Solution {
public:
    // 邻接表
    vector <int> G[105];
    // 入度
    int deg[105];
    
    bool hasCycle(string graph) {
        // 输入：
"1->4,2->5,3->6,3->7,4->8,5->8,5->9,6->9,6->11,7->11,8->12,9->12,9->13,10->13,10->14,11->10,11->14"
        stringstream ss(graph);
        int u, v;
        char ch1, ch2;
        while (ss >> u >> ch1 >> ch2 >> v) {
            G[u].push_back(v);
            deg[v]++;
            if (!(ss >> ch1)) {
                break;
            }
        }
        
       ...
    }
};
```



## 字符串转数字

`int stoi(str)`

`long stol(str)`

`float stof(str)`

`double stod(str)`

## 数字转字符串

`string to_string(num)`

## 最大子数组和

**子数组** 是数组中的一个连续部分。

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int ans = INT_MIN;
        int sum = 0;
        for (int num : nums) {
            sum += num;
            ans = max(ans, sum);
            if (sum < 0) {
                sum = 0;
            }
        }

        return ans;
    }
};
```



## gcd

## lcm

# 图论

## 判环（拓扑排序）

```cpp
class Solution {
public:
    // 邻接表
    vector <int> G[105];
    // 入度
    int deg[105];
    
    bool hasCycle(string graph) {
        // 输入：
"1->4,2->5,3->6,3->7,4->8,5->8,5->9,6->9,6->11,7->11,8->12,9->12,9->13,10->13,10->14,11->10,11->14"
        stringstream ss(graph);
        int u, v;
        char ch1, ch2;
        while (ss >> u >> ch1 >> ch2 >> v) {
            G[u].push_back(v);
            deg[v]++;
            if (!(ss >> ch1)) {
                break;
            }
        }
        
        // 遍历所有节点入度,入度为0的入队
        queue <int> q;
        for (int i = 1; i <= 100; i++) {
            if (deg[i] == 0) {
                q.push(i);
            }
        }
        int cnt = 100;
        while (!q.empty()) {
            int cur = q.front();
            q.pop();
            cnt--;
            for (int v : G[cur]) {
                deg[v]--;
                if (deg[v] == 0) {
                    q.push(v);
                }
            }
        }
        
        return cnt != 0;
    }
};
```



dfs

bfs

floyd算法

dijkstra算法

拓扑排序

## 邻接表构图

```c++
const int maxn = 1005;
const int maxm = maxn * maxn / 2;

struct Edge {
    int to, next;
}e[maxm];

int head[maxn];
int num = 0;
bool vis[maxn];

void init() {
    memset(vis, 0, sizeof(vis));
    memset(head, -1, sizeof(head));
}

void add(int from, int to) {
    e[num].to = to;
    e[num].next = head[from];
    head[from] = num++;
}


for (int i = head[cur]; i != -1; i = e[i].next) {
    
}
```

# 位运算

## 求x二进制下有多少个1

```
__builtin_popcount(x)
```

