---
title: "算法模版"
date: 2022-02-28T21:31:05+08:00
draft: false
tags: [专业知识]
categories: [笔记]
---



# LRU缓存

```c++
struct Node {
    int key, val;
    Node* next;
    Node* prev;
    Node(): key(0), val(0), next(NULL), prev(NULL) {};
    Node(int key, int val): key(key), val(val), next(NULL), prev(NULL) {} ;
};


class Solution {
    int len, cap;
    Node* head;
    Node* tail;
    unordered_map <int, Node*> mp;
    
public:
    Solution(int capacity){
        len = 0;
        cap = capacity;
        head = new Node();
        tail = new Node();
        head->next = tail;
        tail->prev = head;
    }
    
    void removeNode(Node* node) {
        node->next->prev = node->prev;
        node->prev->next = node->next;
    }
    
    void addToHead(Node* node) {
        node->next = head->next;
        node->prev = head;
        head->next->prev = node;
        head->next = node;
    }
    
    Node* removeTail() {
        auto node = tail->prev;
        removeNode(node);
        return node;
    }
    
    void moveToHead(Node* node) {
        removeNode(node);
        addToHead(node);
    }
    
    int get(int key) {
        if (!mp.count(key)) {
            return -1;
        }
        auto node = mp[key];
        moveToHead(node);
        return node->val;
    }
    
    void set(int key, int value){
         if (!mp.count(key)) {
             auto node = new Node(key, value);
             mp[key] = node;
             addToHead(node);
             len++;
             
             if (len > cap) {
                 auto removed = removeTail();
                 mp.erase(removed->key);
                 delete(removed);
                 len--;
             }
         } else {
             auto node = mp[key];
             node->val = value;
             moveToHead(node);
         }
    }
};

```



 

# STL

## vector

### 首部插入元素

```c++
v.insert(v.begin(), num);
```

### 尾部插入元素

```c++
v.push_back(num);
```

### 求和

```c++
accumulate(nums.begin(), nums.end(), 0);
```

### 最大元素

```
*max_element(nums.begin(), nums.end());
```

### 排序

```cpp
sort(nums.begin(), nums.end());
sort(nums.begin(), nums.end(), greater<int>());
```







## map

### 删除某元素

```c++
mp.earse(x)
```

### 判断元素x是否存在

```c++
mp.count(x) // 存在返回1，不存在返回0
```

或者

```c++
if (mp.find(x) != mp.end())
```

### 遍历map中的元素(unordered_map与map)

注意，以下两种方式只适合map遍历，因为map基于红黑树实现，内部数据是有序的。

不适合unordered_map遍历，因为u_map是基于哈希表实现的，内部数据是无序的

```c++
for (auto& [_, cnt]: mp) {
    imax += cnt;
    ans = max(ans, imax);
}
```

```c++
for (auto& it: mp) {
    imax += it.second;
    ans = max(ans, imax);
}
```

![img](https://pic1.zhimg.com/80/v2-e7a0e37ae8457359287f99f9859dda28_720w.jpg)



# 技巧

## gcd

## lcm

## 离散化

```c++
class Solution {
public:
    vector<int> arrayRankTransform(vector<int>& arr) {
        vector <int> temp = arr;
        sort(temp.begin(), temp.end());
        temp.erase(unique(temp.begin(), temp.end()), temp.end());
        for (auto &x : arr) {
            x = upper_bound(temp.begin(), temp.end(), x) - temp.begin();
        }

        return arr;
    }
};
```

## 随机选取（蓄水池抽样算法）

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
    ListNode* head;

public:
    Solution(ListNode* head) {
        this->head = head;
    }
    
    int getRandom() {
        int i = 1;
        int ans =0;

        for (auto node = head; node; node = node->next) {
            if (rand() % i == 0) {
                ans = node->val;
            }
            i++;
        }

        return ans;
    }
};

/**
 * Your Solution object will be instantiated and called as such:
 * Solution* obj = new Solution(head);
 * int param_1 = obj->getRandom();
 */
```



## 判断质数

```c++
bool isPrime(int x) {
        if (x < 2) {
            return false;
        }
        for (int i = 2; i * i <= x; ++i) {
            if (x % i == 0) {
                return false;
            }
        }
        return true;
    }
```

统计1-n质数数量

```c++
int primes(int n) {
    bool is[105];
    memset(is, true, sizeof(is));

    // 注意这里用long long, 因为后面有i * i 
    for (long long i = 2; i * i <= n; i++) {
        if (is[i]) {
            for (long long j = i * i; j <= n; j += i) {
                is[j] = false;
            } 
        }
    }

    int ret = 0;
    for (int i = 2; i <= n; i++) {
        if (is[i]) {
            ret++;
        }
    }

    return ret;
}
```



## 差分数组

```c++
class Solution {
public:
    int busyStudent(vector<int>& startTime, vector<int>& endTime, int queryTime) {
        vector <int> c(1005);
        for (int i = 0; i < startTime.size(); i++) {
            c[startTime[i]]++;
            c[endTime[i] + 1]--;
        }
        int cnt = 0;
        for (int i = 0; i <= queryTime; i++) {
            cnt += c[i];
        }
        return cnt;
    }
};
```



## C++ 浮点数比较

```c++
const double EPS = 1e-6;

// 0 =, 1 >, -1 <
int dcmp(double x, double y)
{
    if(fabs(x - y) < eps){
        return 0;
    } else {
        return fabs(x - y) > 0 ? 1 : -1;
    }
}
```

## 二分

在排序数组中查找某元素的第一个和最后一个位置

lower_bound, 查找符合条件的第一个元素(**左边界**)

查找符合条件的最后一个元素，实际上就是upper_bound - 1(**右边界**)，因为有-1，所以除了判断l - 1 < n，还要判断l - 1 >= 0

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        vector <int> ans;
        int n = nums.size();
        int l, r;

        l = 0, r = n;
        while (l < r) {
            int mid = l + (r - l) / 2;
            if (nums[mid] >= target) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        if (l < n && nums[l] == target) {
            ans.push_back(l);
        } else {
            ans.push_back(-1);
        }

        l = 0, r = n;
        while (l < r) {
            int mid = l + (r - l) / 2;
            if (nums[mid] > target) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        if (l - 1 < n && l - 1 >= 0 && nums[l - 1] == target) {
            ans.push_back(l - 1);
        } else {
            ans.push_back(-1);
        }

        return ans;
    }
};
```

## 快速幂

```c++
double quickPow(double base, long long exp) {
    if (exp < 0) {
        base = 1 / base;
        exp = -exp;
    }
    
    double ans = 1;
    while (exp) {
        if (exp % 2 == 1) {
            ans *= base;
            exp -= 1;
        } else {
            base *= base;
            exp /= 2;
        }
    }
    
    return ans;
}
```

## 结构体操作

```c++
struct Node {
    int idx, val, mapped;
    //构造函数
    Node(int idx, int val, int mapped): idx(idx), val(val), mapped(mapped){}
	//自定义比较符
    bool operator<(const Node obj)const {
        if (mapped == obj.mapped) {
            return idx < obj.idx;
        }
        return mapped < obj.mapped;
    }
};
```



# 树

## 字典树

例题：https://leetcode.cn/problems/replace-words/ 模版替换

```c++
// 字典树数据结构
struct Trie {
    unordered_map <char, Trie*> mp;
};

class Solution {
public:
    string replaceWords(vector<string>& dictionary, string sentence) {
        // 构建字典树
        Trie* trie = new Trie();
        for (auto& word: dictionary) {
            auto cur = trie;
            for (char& ch : word) {
                if (!cur->mp.count(ch)) {
                    cur->mp[ch] = new Trie();
                }
                cur = cur->mp[ch];
            }
            cur->mp['#'] = new Trie();
        }

        vector <string> words = split(sentence, ' ');
        for (auto& word : words) {
            word = findRoot(word, trie);
        }
		
        string ans;
        for (int i = 0; i < words.size() - 1; i++) {
            ans += words[i] + " ";
        }
        ans += words.back();

        return ans;
    }

    vector<string> split(string str, char ch) {
        ...
    }
	// 跟根据字典树返回词根
    string findRoot(string& word, Trie* trie) {
        string root;
        auto cur = trie;
        for (char ch : word) {
            if (cur->mp.count('#')) {
                return root;
            } else if (!cur->mp.count(ch)) {
                return word;
            } else {
                root.push_back(ch);
                cur = cur->mp[ch];
            }
        }

        return root;
    }
};
```

```c++
struct Trie {
    bool isFinished;
    unordered_map <char, Trie*> mp;
};

class MagicDictionary {
public:
    Trie* root;

    MagicDictionary() {
        root = new Trie();
    }
    
    void buildDict(vector<string> dictionary) {
        for (auto& word : dictionary) {
            auto cur = root;
            for (char ch : word) {
                if (!cur->mp.count(ch)) {
                    cur->mp[ch] = new Trie();
                }
                cur = cur->mp[ch];
            }
            cur->isFinished = true;
        }
    }
```







# 字符串

## string 删除操作

`erase(size_type pos=0, size_type n=npos);`

即从给定起始位置`pos`处开始删除, 要删除字符的长度为`n`, 返回值修改后的string对象引用

`iterator erase(const_iterator position)`

删除迭代器位置处的单个字符, 并返回`下个元素`的迭代器

`iterator erase(const_iterator first, const_iterator last)`

删除迭代器`[first, last)`区间的所有字符,返回一个指向被删除的最后一个元素的下一个字符的迭代器.

`pop_back()`方法也可以用来删除元素, 但是只能删除string的最后一个元素

## C++手动实现Split

```C++
vector<string> split(string str, char ch) {
    int pos = 0;
    int start = 0;
    vector<string> ret;

    while (pos < str.size()) {
        while (pos < str.size() && str[pos] == ch) {
            pos++;
        }
        start = pos;
        while (pos < str.size() && str[pos] != ch) {
            pos++;
        }
        if (start < str.size()) {
            ret.emplace_back(str.substr(start, pos - start));
        }
    }

    return ret;
}
```



## 使用stringstream解析字符串

```c++
class Solution {
public:
    // 邻接表
    vector <int> G[105];
    // 入度
    int deg[105];
    
    bool hasCycle(string graph) {
        // 输入：
"1->4,2->5,3->6,3->7,4->8,5->8,5->9,6->9,6->11,7->11,8->12,9->12,9->13,10->13,10->14,11->10,11->14"
        stringstream ss(graph);
        int u, v;
        char ch1, ch2;
        while (ss >> u >> ch1 >> ch2 >> v) {
            G[u].push_back(v);
            deg[v]++;
            if (!(ss >> ch1)) {
                break;
            }
        }
        
       ...
    }
};
```

```c++
class Solution {
public:
    string fractionAddition(string expression) {
        stringstream ss(expression);
        int A = 0, B = 1, num1, num2;
        char ch;
		
        while (ss >> num1 >> ch >> num2) {
            A = A * num2 + B * num1;
            B *= num2;
            int g = abs(__gcd(A, B));
            A /= g;
            B /= g;
        }

        return to_string(A) + "/" + to_string(B);
    }
};
```



## 字符串转数字

`int stoi(str)`

`long stol(str)`

`float stof(str)`

`double stod(str)`

## 数字转字符串

`string to_string(num)`

## 最大子数组和

**子数组** 是数组中的一个连续部分。

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int ans = INT_MIN;
        int sum = 0;
        for (int num : nums) {
            sum += num;
            ans = max(ans, sum);
            if (sum < 0) {
                sum = 0;
            }
        }

        return ans;
    }
};
```



## 

# 图论

## 并查集

```c++
int fa[100005];
int rank[100005];

void init(int n) {
    memset(rank, 0, sizeof(rank));
    for (int i = 0; i < n; i++) {
        fa[i] = i;
    }
}

int find(int x) {
    if (x == fa[x]) {
        return x;
    }
    return fa[x] = find(fa[x]);
}

void unit(int x, int y) {
    x = find(x);
    y = find(y);
    if (x == y) {
        return;
    }

    if (rank[x] < rank[y]) {
        fa[x] = y;
    } else {
        fa[y] = x;
        if (rank[x] == rank[y]) {
            rank[x]++;
        }
    }
}

bool same(int x, int y) {
    return find(x) == find(y);
}
```



## 判环（拓扑排序）

```cpp
class Solution {
public:
    // 邻接表
    vector <int> G[105];
    // 入度
    int deg[105];
    
    bool hasCycle(string graph) {
        // 输入：
"1->4,2->5,3->6,3->7,4->8,5->8,5->9,6->9,6->11,7->11,8->12,9->12,9->13,10->13,10->14,11->10,11->14"
        stringstream ss(graph);
        int u, v;
        char ch1, ch2;
        while (ss >> u >> ch1 >> ch2 >> v) {
            G[u].push_back(v);
            deg[v]++;
            if (!(ss >> ch1)) {
                break;
            }
        }
        
        // 遍历所有节点入度,入度为0的入队
        queue <int> q;
        for (int i = 1; i <= 100; i++) {
            if (deg[i] == 0) {
                q.push(i);
            }
        }
        int cnt = 100;
        while (!q.empty()) {
            int cur = q.front();
            q.pop();
            cnt--;
            for (int v : G[cur]) {
                deg[v]--;
                if (deg[v] == 0) {
                    q.push(v);
                }
            }
        }
        
        return cnt != 0;
    }
};
```



dfs

bfs

floyd算法

dijkstra算法

拓扑排序

## 邻接表构图

```c++
const int maxn = 1005;
const int maxm = maxn * maxn / 2;

struct Edge {
    int to, next;
}e[maxm];

int head[maxn];
int num = 0;
bool vis[maxn];

void init() {
    memset(vis, 0, sizeof(vis));
    memset(head, -1, sizeof(head));
}

void add(int from, int to) {
    e[num].to = to;
    e[num].next = head[from];
    head[from] = num++;
}


for (int i = head[cur]; i != -1; i = e[i].next) {
    
}
```

# 位运算

## 求x二进制下有多少个1

```
__builtin_popcount(x)
```

或者

```c++
#include <bits/stdc++.h>
using namespace std;

int main() {
    int res = 0;
    
	long long x;
    cin >> x;
    while (x) {
        n &= n - 1;
        res++;
    }
    
    cout << res << endl;
}
```







