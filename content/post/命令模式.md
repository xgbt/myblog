---
title: "命令模式"
date: 2021-12-09T16:29:53+08:00
draft: false
tags: [设计模式]
categories: [笔记]
---

# 定义

请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。

# 命令消息模式与命令模式

待续。。https://www.ledjonbehluli.com/posts/wash-tunnel/command_message/

# 样例1

本例中，只处理单个Receiver。

![Command-Class diagram1](/Command-Class diagram1.jpg)

```java
public interface Command {
    // Typically this method does not take any argument.
    // Some of the reasons are:
    // 1.We supply all the information when it is created.
    // 2.Invoker may reside in different address space.etc.
    void executeCommand();
}
```

```java
class Receiver {
    public void performUndo() {
        System.out.println("Performing an undo command in Receiver.");
    }

    public void performRedo() {
        System.out.println("Performing an redo command in Receiver.");
    }

    /*Optional method-If you want to perform
     any prior tasks before undo operations.*/
    public void doOptionalTaskPriorToUndo() {
        System.out.println("Executing -Optional Task/s prior to execute undo command.");
    }

    /*Optional method-If you want to perform
     any prior tasks before redo operations*/
    public void doOptionalTaskPriorToRedo() {
        System.out.println("Executing -Optional Task/s prior to execute redo command.");
    }
}
```

```java
public class MyUndoCommand implements Command {
    private final Receiver receiver;

    public MyUndoCommand(Receiver receiver) {
        this.receiver = receiver;
    }

    @Override
    public void executeCommand() {
        //Perform any optional task prior to UnDo
        receiver.doOptionalTaskPriorToUndo();
        //Call UnDo in receiver now
        receiver.performUndo();
    }
}

```

```java
class MyRedoCommand implements Command {
    private final Receiver receiver;

    public MyRedoCommand(Receiver receiver) {
        this.receiver = receiver;
    }

    @Override
    public void executeCommand() {
        //Perform any optional task prior to ReDo
        receiver.doOptionalTaskPriorToRedo();
        //Call ReDo in receiver now
        receiver.performRedo();
    }
}
```

```java
public class Invoker {
    Command commandToBePerformed;

    // Set the command
    public void setCommand(Command command) {
        commandToBePerformed = command;
    }
    // Invoke the command
    public void invokeCommand() {
        commandToBePerformed.executeCommand();
    }
}

```

```java
// Client
public class CommandPatternExample {
    public static void main(String[] args) {
        System.out.println("***Command Pattern Demo***\n");

        /*Client holds both the Invoker and Command Objects*/
        Receiver intendedReceiver = new Receiver();
        MyUndoCommand undoCmd = new MyUndoCommand(intendedReceiver);
        MyRedoCommand redoCmd = new MyRedoCommand(intendedReceiver);

        Invoker invoker = new Invoker();
        invoker.setCommand(undoCmd);
        invoker.invokeCommand();
        invoker.setCommand(redoCmd);
        invoker.invokeCommand();
    }
}

```

## 输出

> ***Command Pattern Demo***
>
> Executing -Optional Task/s prior to execute undo command.
>
> Performing an undo command in Receiver.
>
> Executing -Optional Task/s prior to execute redo command.
>
> Performing an redo command in Receiver.



#  样例2

本例中，可处理多个Receiver。本例中多加了一个Receiver的通用接口。两个接收器收到相同的命令，但可以执行不同的操作。

![Command-Class diagram2](/Command-Class diagram2.jpg)

```java
interface Command {
    void executeDo();
    void executeUnDo();
}
```

```java
public class AdditionCommand implements Command {
    private final Receiver receiver;

    public AdditionCommand(Receiver receiver) {
        this.receiver = receiver;
    }

    @Override
    public void executeDo() {
        receiver.performDo();
    }

    @Override
    public void executeUnDo() {
        receiver.performUnDo();
    }
}
```

```java
public class PowerCommand implements Command {
    private final Receiver receiver;

    public PowerCommand(Receiver receiver) {
        this.receiver = receiver;
    }

    @Override
    public void executeDo() {
        receiver.performDo();
    }

    @Override
    public void executeUnDo() {
        receiver.performUnDo();
    }
}
```


```java
//To deal with multiple receivers , we are using interfaces here
interface Receiver {
    //It will add 2 with a number or switch on the m/c
    void performDo();

    //It will subtract 2 from a number or switch off the m/c
    void performUnDo();
}
```

```java
public class Receiver1 implements Receiver {
    private int myNumber;

    public Receiver1() {
        myNumber = 10;
        System.out.println("Receiver1 initialized with " + myNumber);
        System.out.println("The objects of receiver1 cannot set beyond " + myNumber);
    }

    public int getMyNumber() {
        return myNumber;
    }

    public void setMyNumber(int myNumber) {
        this.myNumber = myNumber;
    }

    @Override
    public void performDo() {
        System.out.println("Received an addition request.");
        int presentNumber = getMyNumber();
        setMyNumber(presentNumber + 2);
        System.out.println(presentNumber + " + 2 =" + this.myNumber);
    }

    @Override
    public void performUnDo() {
        System.out.println("Received an undo addition request.");
        int presentNumber = this.myNumber;
        //We started with number 10.We'll not decrease further.
        if (presentNumber > 10) {
            setMyNumber(this.myNumber - 2);
            System.out.println(presentNumber + " - 2 =" + this.myNumber);
        } else {
            System.out.println("Nothing more to undo...");
        }
    }
}
```

```java
public class Receiver2 implements Receiver {
    boolean status;

    public Receiver2() {
        System.out.println("Receiver2 initialized.");
        status = false;
    }

    @Override
    public void performDo() {
        System.out.println("Received a system power on request.");
        if (status == false) {
            System.out.println("System is starting up.");
            status = true;
        } else {
            System.out.println("System is already running. So, power on request is ignored.");
        }
    }

    @Override
    public void performUnDo() {
        System.out.println("Received a undo request.");
        if (status == true) {
            System.out.print("System is currently powered on.");
            status = false;
            System.out.println("Undo request processed.System is switched off now.");
        } else {
            System.out.print("System is switched off at present.");
            status = true;
            System.out.println("Undo request processed.System is powered on now.");
        }
    }
}
```

```java
public class Invoker {
    Command commandToBePerformed;

    public void setCommand(Command command) {
        this.commandToBePerformed = command;
    }

    public void executeCommand() {
        commandToBePerformed.executeDo();
    }

    public void undoCommand() {
        commandToBePerformed.executeUnDo();
    }
}
```

```java
//Client
public class ModifiedCommandPatternExample {
    public static void main(String[] args) {
        System.out.println("***Command Pattern Q&As***");
        System.out.println("***A simple demo with undo supported operations***\n");
        //Client holds  both the Invoker and Command Objects

        Invoker invoker = new Invoker();
        Receiver intendedreceiver;
        Command currentCmd;

        System.out.println("-----Testing operations in Receiver1-----");
        intendedreceiver = new Receiver1();
        currentCmd = new AdditionCommand(intendedreceiver);
        invoker.setCommand(currentCmd);
        System.out.println("*Testing single do/undo operation*");
        invoker.executeCommand();
        invoker.undoCommand();
        System.out.println("_______");
        System.out.println("**Testing a series of do/undo operations**");
        //Executed the command 2 times
        invoker.executeCommand();
        invoker.executeCommand();
        //Trying to undo 3 times
        invoker.undoCommand();
        invoker.undoCommand();
        invoker.undoCommand();


        System.out.println("\n-----Testing operations in Receiver2-----");
        intendedreceiver = new Receiver2();
        currentCmd = new PowerCommand(intendedreceiver);
        invoker.setCommand(currentCmd);
        System.out.println("*Testing single do/undo operation*");
        invoker.executeCommand();
        invoker.undoCommand();
        System.out.println("_______");
        System.out.println("**Testing a series of do/undo operations**");
        //Executing the command 2 times
        invoker.executeCommand();
        invoker.executeCommand();
        //Trying to undo 3 times
        invoker.undoCommand();
        invoker.undoCommand();
        invoker.undoCommand();
    }
}
```

## 输出

> ***Command Pattern Q&As***
>
> *A simple demo with undo supported operations***
>
> -----Testing operations in Receiver1-----
>
> Receiver1 initialized with 10
>
> The objects of receiver1 cannot set beyond 10
>
> *Testing single do/undo operation*
>
> Received an addition request.
>
> 10 + 2 =12
>
> Received an undo addition request.
>
> 12 - 2 =10
>
> ---
> **Testing a series of do/undo operations**
>
> Received an addition request.
>
> 10 + 2 =12
>
> Received an addition request.
>
> 12 + 2 =14
>
> Received an undo addition request.
>
> 14 - 2 =12
>
> Received an undo addition request.
>
> 12 - 2 =10
>
> Received an undo addition request.
>
> Nothing more to undo...
>
> -----Testing operations in Receiver2-----
>
> Receiver2 initialized.
>
> Testing single do/undo operation*
>
> Received a system power on request.
>
> System is starting up.
>
> Received a undo request.
>
> System is currently powered on. Undo request processed.System is switched off now.
>
> ---
>
> **Testing a series of do/undo operations**
>
> Received a system power on request.
>
> System is starting up.
>
> Received a system power on request.
>
> System is already running. So, power on request is ignored.
>
> Received a undo request.
>
> System is currently powered on.Undo request processed.System is switched off now.
>
> Received a undo request.
>
> System is switched off at present.Undo request processed.System is powered on now.
>
> Received a undo request.
>
> System is currently powered on.Undo request processed.System is switched off now.

# 优点

- 创建请求与最终执行请求是分离的，客户端不需要知道调用者如何执行操作。
- 可以创建命令序列。
- 可以在不影响现有系统的情况下添加新的命令。
- 最重要的，支持undo/redo操作。

# 缺点

- 命令越多，后期需要创建的类也越多，会更难维护。
- 因为我们将命令和客户端代码解耦，所以如果发生错误情况会难以处理。

# 参考文献

1. Sarcar V. Java design patterns[M]. Apress, 2016.

