---
title: "子序列问题"
date: 2021-07-26T14:31:05+08:00
draft: false
tags: [算法]
categories: [笔记]
---



## [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。

- 方法1：动态规划，$dp[i][j]$​​ 表示 $text1[0:i]$ 与 $text2[0:j]$​​ 的最长公共子序列的长度。时间复杂度O(nm)，空间复杂度O(nm)。

```c++
class Solution {
private:
    int dp[1005][1005];
public:
    int longestCommonSubsequence(string text1, string text2) {
        int n = text1.size();
        int m = text2.size();

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (text1[i - 1] == text2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        return dp[n][m];
    }
};
```





## [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

 

- 方法1：动态规划。$dp[i]$​ 为考虑前 i 个元素，以第 i 个数字结尾的最长上升子序列的长度，**注意 $nums[i] $​必须被选取**。时间复杂度O($n^2$​)，空间复杂度O(n)。

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        if (n == 0) {
            return 0;
        }
        vector<int> dp(n, 0);

        for (int i = 0; i < n; i++) {
            dp[i] = 1;
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i]) {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
        }

        return *max_element(dp.begin(), dp.end());
    }
};
```



- 方法2：贪心+二分。

我们要使上升子序列尽可能的长，则应该让序列上升得尽可能慢，因此希望每次在上升子序列最后加上的那个数尽可能的小。基于上面的贪心思路，我们维护数组 $d[i]$ ，表示长度为 $i$ 的最长上升子序列的末尾元素的最小值。

**注意到 $ d[i]$​] 是关于 $i$​​​​ 单调递增的。**

步骤：遍历数组$num$​中的每个元素，并更新数组 $d$ 的值。

- 如果 $nums[i] > d[len]$​，则直接把$nums[i]$​ 放到数组$d$​ 末尾，并且$ len++$​。
- 否则在 $d$ 数组中二分查找，找到第一个比 $nums[i]$ 小的数 $d[k]$ ，使$ d[k + 1] $= $nums[i]$。

时间复杂度O(nlogn)，空间复杂度O(n)

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        vector <int> d;
  
        for (int num : nums) {
            auto it = lower_bound(d.begin(), d.end(), num);
            if (it != d.end()) {
                *it = num;
            }
            else {
                d.push_back(num);
            }
        }

        return d.size();
    }
};
```





## [1713. 得到子序列的最少操作次数](https://leetcode-cn.com/problems/minimum-operations-to-make-a-subsequence/)

给你一个数组 target ，包含若干 互不相同 的整数，以及另一个整数数组 arr ，arr 可能 包含重复元素。

每一次操作中，你可以在 arr 的任意位置插入任一整数。比方说，如果 arr = [1,4,1,2] ，那么你可以在中间添加 3 得到 [1,4,3,1,2] 。你可以在数组最开始或最后面添加整数。

请你返回 最少 操作次数，使得 target 成为 arr 的一个子序列。

一个数组的 子序列 指的是删除原数组的某些元素（可能一个元素都不删除），同时不改变其余元素的相对顺序得到的数组。比方说，[2,7,4] 是 [4,2,3,7,2,1,4] 的子序列（加粗元素），但 [2,4,2] 不是子序列。



- 方法1：贪心+二分

记数组 target 的长度为 n，数组arr 的长度为 m。

根据题意，target 和 arr 这两个数组的公共子序列越长，需要添加的元素个数也就越少。因此最少添加的元素个数为 n 减去两数组的最长公共子序列的长度。

变成了求最长公共子序列，但是不能动态规划，因为O(nm)会在本题会超时。

由于 **target 的元素互不相同**，我们把target中的元素转换为0...n-1的下标，，并将 arr 中的元素映射到对应的下标上，对于arr中不存在于 target 中的元素，由于其必然不会在最长公共子序列中，可将其忽略。

则求原数组的最长公共子序列等价于求上述转换后的两数组的最长公共子序列。

又现在的 **target 是严格单调递增的**，所以 arr 在最长公共子序列中的部分也必须是严格单调递增的，因此本问题进一步地转换成求 arr 的最长递增子序列的长度。

后续步骤与题300相同。

时间复杂度O(n + mlogm)，空间复杂度O(n+m)。

```c++
class Solution {
public:
    int minOperations(vector<int>& target, vector<int>& arr) {
        int n = target.size();
        map <int, int> pos;

        for (int i = 0; i < n; i++) {
            pos[target[i]] = i;
        }

        vector <int> d;

        for (int x : arr) {
            if (!pos.count(x)) continue;
            int idx = pos[x];
            auto it = lower_bound(d.begin(), d.end(), idx);
            if (it != d.end()) {
                *it = idx;
            }
            else {
                d.push_back(idx);
            }
        }

        return n - d.size();
    }
};
```

