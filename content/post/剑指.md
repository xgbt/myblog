---
title: "《剑指Offer》"
date: 2021-07-09T14:28:20+08:00
draft: false
tags: [算法]
categories: [笔记]
---





## 03. 数组中重复的数字

在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

示例 1：

> 输入：
> [2, 3, 1, 0, 2, 5, 3]
> 输出：2 或 3 


限制：2 <= n <= 100000

- 方法1：哈希表，时间复杂度O(n)，空间复杂度O(n)

```c++
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        unordered_map <int, int> mp;
        for (int num : nums) {
            if (mp[num] == 1) {
                return num;
            }
            mp[num]++;
        }
        return -1;
    }
};
```

- 方法2：排序，时间复杂度O(nlogn)，空间复杂度O(1)

```c++
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size() - 1; i++) {
            if (nums[i] == nums[i + 1]) {
                return nums[i];
            }
        }
        return -1;
    }
};
```

- 方法3：题目中提到 「在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内」，利用这个条件，遍历数组并通过交换操作，使元素的索引与值 一一对应，时间复杂度O(n)，空间复杂度O(1)。

```c++
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] == i) {
                continue;
            }
            if (nums[i] == nums[nums[i]]) {
                return nums[i];
            }
            swap(nums[i], nums[nums[i]]);
        }
        
        return -1;
    }
};
```



## 04. 二维数组中的查找

在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

示例: 现有矩阵 matrix 如下：

> [
>   [1,   4,  7, 11, 15],
>   [2,   5,  8, 12, 19],
>   [3,   6,  9, 16, 22],
>   [10, 13, 14, 17, 24],
>   [18, 21, 23, 26, 30]
> ]

给定 target = 5，返回 true。

给定 target = 20，返回 false。

限制：

0 <= n <= 1000

0 <= m <= 1000

- 方法1：利用题目条件，从右上角元素出发，如果target大于该元素则往下移动，如果target小于该元素则向左移动，时间复杂度O(nm)，空间复杂度O(1)。

```c++
class Solution {
public:
    bool findNumberIn2DArray(vector<vector<int>>& matrix, int target) {
        if (matrix.size() == 0 || matrix[0].size() == 0) {
            return false;
        }
        
        int n = matrix.size();
        int m = matrix[0].size();
        int x = 0, y = m - 1;
        while (x < n && y >= 0) {
            if (target < matrix[x][y]) {
                y--;
            }
            else 
            if (target > matrix[x][y]) {
                x++;
            }
            else {
                return true;
            }
        }

        return false;
    }
};
```



## 05. 替换空格

实现一个函数，把字符串 s 中的每个空格替换成"%20"。

示例 1：

> 输入：s = "We are happy."
> 输出："We%20are%20happy."


限制：

0 <= s 的长度 <= 10000

- 方法1：遍历字符串s，时间复杂度O(n)，空间复杂度O(n)。

```c++
class Solution {
public:
    string replaceSpace(string s) {
        string ans = "";
        for (char ch : s) {
            if (ch == ' ') {
                ans += "%20";
            }
            else {
                ans += ch;
            }
        }
        return ans;
    }
};
```



## 06. 从尾到头打印链表

输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。

示例 1：

> 输入：head = [1,3,2]
> 输出：[2,3,1]


限制：

0 <= 链表长度 <= 10000

- 方法1：递归，时间复杂度O(n)，空间复杂度O(n)。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> ans;

    void reCursion(ListNode* head) {
        if (head == nullptr) {
            return;
        }
        reCursion(head->next);
        ans.emplace_back(head->val);
    }
    
    vector<int> reversePrint(ListNode* head) {
        reCursion(head);
        return ans;
    }
};
```

- 方法2：栈，时间复杂度O(n)，空间复杂度O(n)。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> reversePrint(ListNode* head) {
        stack<int> stk;
        vector<int> ans;

        while (head) {
            stk.push(head->val);
            head = head->next;
        } 
        while (!stk.empty()) {
            ans.push_back(stk.top());
            stk.pop();
        }

        return ans;
    }
};
```



## 07. 重建二叉树

输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

- 方法1：递归，时间复杂度O(n)，空间复杂度O(n)，除去返回的答案需要的O(n) 空间之外，我们还需要使用O(n) 的空间存储哈希映射，以及O(h)（其中 h 是树的高度）的空间表示递归时栈空间。这里h<n，所以总空间复杂度为 O(n)。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
private:
    unordered_map <int, int> mp;
public:
    TreeNode* myBuildTree(vector<int> preorder, vector<int> inorder, int pre_left, int pre_right, int in_left, int in_right) {
        if (pre_left > pre_right) {
            return nullptr;
        }

        // 前序遍历中的第一个节点是根节点,在中序遍历中进行定位
        int in_root = mp[preorder[pre_left]];
        // 构造根节点
        TreeNode* root = new TreeNode(preorder[pre_left]);
        // 求左子树的长度方便计算
        int len = in_root - in_left;
        root->left = myBuildTree(preorder, inorder, pre_left + 1, pre_left + len, in_left, in_root - 1);
        root->right = myBuildTree(preorder, inorder, pre_left + len + 1, pre_right, in_root + 1, in_right);

        return root;
    }

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        for (int i = 0; i < preorder.size(); i++) {
            mp[inorder[i]] = i;
        }

        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);
    }
};
```

- 方法2：迭代，时间复杂度O(n)，空间复杂度O(n)，太麻烦了。

``` c++
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if (!preorder.size()) {
            return nullptr;
        }
        TreeNode* root = new TreeNode(preorder[0]);
        stack<TreeNode*> stk;
        stk.push(root);
        int inorderIndex = 0;
        for (int i = 1; i < preorder.size(); ++i) {
            int preorderVal = preorder[i];
            TreeNode* node = stk.top();
            if (node->val != inorder[inorderIndex]) {
                node->left = new TreeNode(preorderVal);
                stk.push(node->left);
            }
            else {
                while (!stk.empty() && stk.top()->val == inorder[inorderIndex]) {
                    node = stk.top();
                    stk.pop();
                    ++inorderIndex;
                }
                node->right = new TreeNode(preorderVal);
                stk.push(node->right);
            }
        }
        return root;
    }
};
/*
作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
*/
```





## 09. 用两个栈实现队列

用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 `appendTail` 和 `deleteHead` ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，`deleteHead` 操作返回 -1 )

- 方法1：模拟，时间复杂度O(1)，空间复杂度O(n)。

```c++
class CQueue {
public:

    stack<int> s1;
    stack<int> s2;

    CQueue() {
        while (!s1.empty()) {
            s1.pop();
        }
        while (!s2.empty()) {
            s2.pop();
        }
    }
    
    void appendTail(int value) {
        s1.push(value);
    }
    
    int deleteHead() {
        if (s2.empty()) {
            while(!s1.empty()) {
                s2.push(s1.top());
                s1.pop();
            }
        }

        if (s2.empty()) {
            return -1;
        }
        else {
            int ret = s2.top();
            s2.pop();
            return ret;
        }
    }
};

/**
 * Your CQueue object will be instantiated and called as such:
 * CQueue* obj = new CQueue();
 * obj->appendTail(value);
 * int param_2 = obj->deleteHead();
 */
```

