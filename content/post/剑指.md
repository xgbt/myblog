---
title: "剑指Offer"
date: 2021-07-09T14:28:20+08:00
draft: false
tags: [算法]
categories: [笔记]
---



## 03. 数组中重复的数字★

在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

示例 1：

> 输入：
> [2, 3, 1, 0, 2, 5, 3]
> 输出：2 或 3 


限制：2 <= n <= 100000

- 方法1：哈希表，时间复杂度O(n)，空间复杂度O(n)

```c++
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        unordered_map <int, int> mp;
        for (int num : nums) {
            if (mp[num] == 1) {
                return num;
            }
            mp[num]++;
        }
        return -1;
    }
};
```

- 方法2：排序，时间复杂度O(nlogn)，空间复杂度O(1)

```c++
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size() - 1; i++) {
            if (nums[i] == nums[i + 1]) {
                return nums[i];
            }
        }
        return -1;
    }
};
```

- 方法3：题目中提到 「在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内」，利用这个条件，遍历数组并通过交换操作，使元素的索引与值 一一对应，时间复杂度O(n)，空间复杂度O(1)。

```c++
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] == i) {
                continue;
            }
            if (nums[i] == nums[nums[i]]) {
                return nums[i];
            }
            swap(nums[i], nums[nums[i]]);
        }
        
        return -1;
    }
};
```



## 04. 二维数组中的查找★

在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

示例: 现有矩阵 matrix 如下：

> [
>   [1,   4,  7, 11, 15],
>   [2,   5,  8, 12, 19],
>   [3,   6,  9, 16, 22],
>   [10, 13, 14, 17, 24],
>   [18, 21, 23, 26, 30]
> ]

给定 target = 5，返回 true。

给定 target = 20，返回 false。

限制：

0 <= n <= 1000

0 <= m <= 1000

- 方法1：利用题目条件，从右上角元素出发，如果target大于该元素则往下移动，如果target小于该元素则向左移动，时间复杂度O(nm)，空间复杂度O(1)。

```c++
class Solution {
public:
    bool findNumberIn2DArray(vector<vector<int>>& matrix, int target) {
        if (matrix.size() == 0 || matrix[0].size() == 0) {
            return false;
        }
        
        int n = matrix.size();
        int m = matrix[0].size();
        int x = 0, y = m - 1;
        while (x < n && y >= 0) {
            if (target < matrix[x][y]) {
                y--;
            }
            else 
            if (target > matrix[x][y]) {
                x++;
            }
            else {
                return true;
            }
        }

        return false;
    }
};
```



## 05. 替换空格

实现一个函数，把字符串 s 中的每个空格替换成"%20"。

示例 1：

> 输入：s = "We are happy."
> 输出："We%20are%20happy."


限制：

0 <= s 的长度 <= 10000

- 方法1：遍历字符串s，时间复杂度O(n)，空间复杂度O(n)。

```c++
class Solution {
public:
    string replaceSpace(string s) {
        string ans = "";
        for (char ch : s) {
            if (ch == ' ') {
                ans += "%20";
            }
            else {
                ans += ch;
            }
        }
        return ans;
    }
};
```



## 06. 从尾到头打印链表★

输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。

示例 1：

> 输入：head = [1,3,2]
> 输出：[2,3,1]


限制：

0 <= 链表长度 <= 10000

- 方法1：递归，时间复杂度O(n)，空间复杂度O(n)。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> ans;

    void reCursion(ListNode* head) {
        if (head == nullptr) {
            return;
        }
        reCursion(head->next);
        ans.emplace_back(head->val);
    }
    
    vector<int> reversePrint(ListNode* head) {
        reCursion(head);
        return ans;
    }
};
```

- 方法2：栈，时间复杂度O(n)，空间复杂度O(n)。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> reversePrint(ListNode* head) {
        stack<int> stk;
        vector<int> ans;

        while (head) {
            stk.push(head->val);
            head = head->next;
        } 
        while (!stk.empty()) {
            ans.push_back(stk.top());
            stk.pop();
        }

        return ans;
    }
};
```



## 07. 重建二叉树★

输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

- 方法1：递归，时间复杂度O(n)，空间复杂度O(n)，除去返回的答案需要的O(n) 空间之外，我们还需要使用O(n) 的空间存储哈希映射，以及O(h)（其中 h 是树的高度）的空间表示递归时栈空间。这里h<n，所以总空间复杂度为 O(n)。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
private:
    unordered_map <int, int> mp;
public:
    TreeNode* myBuildTree(vector<int> preorder, vector<int> inorder, int pre_left, int pre_right, int in_left, int in_right) {
        if (pre_left > pre_right) {
            return nullptr;
        }

        // 前序遍历中的第一个节点是根节点,在中序遍历中进行定位
        int in_root = mp[preorder[pre_left]];
        // 构造根节点
        TreeNode* root = new TreeNode(preorder[pre_left]);
        // 求左子树的长度方便计算
        int len = in_root - in_left;
        root->left = myBuildTree(preorder, inorder, pre_left + 1, pre_left + len, in_left, in_root - 1);
        root->right = myBuildTree(preorder, inorder, pre_left + len + 1, pre_right, in_root + 1, in_right);

        return root;
    }

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        for (int i = 0; i < preorder.size(); i++) {
            mp[inorder[i]] = i;
        }

        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);
    }
};
```

- 方法2：迭代，时间复杂度O(n)，空间复杂度O(n)，太麻烦了。

``` c++
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if (!preorder.size()) {
            return nullptr;
        }
        TreeNode* root = new TreeNode(preorder[0]);
        stack<TreeNode*> stk;
        stk.push(root);
        int inorderIndex = 0;
        for (int i = 1; i < preorder.size(); ++i) {
            int preorderVal = preorder[i];
            TreeNode* node = stk.top();
            if (node->val != inorder[inorderIndex]) {
                node->left = new TreeNode(preorderVal);
                stk.push(node->left);
            }
            else {
                while (!stk.empty() && stk.top()->val == inorder[inorderIndex]) {
                    node = stk.top();
                    stk.pop();
                    ++inorderIndex;
                }
                node->right = new TreeNode(preorderVal);
                stk.push(node->right);
            }
        }
        return root;
    }
};
/*
作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
*/
```





## 09. 用两个栈实现队列

用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 `appendTail` 和 `deleteHead` ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，`deleteHead` 操作返回 -1 )

- 方法1：模拟，时间复杂度O(1)，空间复杂度O(n)。

```c++
class CQueue {
public:

    stack<int> s1;
    stack<int> s2;

    CQueue() {
        while (!s1.empty()) {
            s1.pop();
        }
        while (!s2.empty()) {
            s2.pop();
        }
    }
    
    void appendTail(int value) {
        s1.push(value);
    }
    
    int deleteHead() {
        if (s2.empty()) {
            while(!s1.empty()) {
                s2.push(s1.top());
                s1.pop();
            }
        }

        if (s2.empty()) {
            return -1;
        }
        else {
            int ret = s2.top();
            s2.pop();
            return ret;
        }
    }
};

/**
 * Your CQueue object will be instantiated and called as such:
 * CQueue* obj = new CQueue();
 * obj->appendTail(value);
 * int param_2 = obj->deleteHead();
 */
```

## 10- I. 斐波那契数列

写一个函数，输入 `n` ，求斐波那契（Fibonacci）数列的第 `n` 项（即 `F(N)`）

- 方法1：dp，时间复杂度O(n)，空间复杂度O(n)。

```c++
#define MOD 1000000007
class Solution {
public:
    map <int, int> mp;
    int fib(int n) {
        mp[0] = 0;
        mp[1] = 1;
        for (int i = 2; i <= n; i++) {
            mp[i] = mp[i - 1] + mp[i - 2];
            mp[i] %= MOD;
        }

        return mp[n];
    }
};
```

## 10- II. 青蛙跳台阶问题

一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 `n` 级的台阶总共有多少种跳法。

青蛙跳台阶问题： `f(0)=1 , f(1)=1 , f(2)=2 ；
斐波那契数列问题： f(0)=0 , f(1)=1 , f(2)=1 。

```c++
#define MOD 1000000007
class Solution {
public:
    int numWays(int n) {
        map <int, int> mp;
        mp[0] = 1;
        mp[1] = 1;
        for (int i = 2; i <= n; i++) {
            mp[i] = mp[i - 1] + mp[i - 2];
            mp[i] %= MOD;
        }

        return mp[n];
    }
};
```



## 11. 旋转数组的最小数字★★

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  

示例 1：

> 输入：[3,4,5,1,2]
> 输出：1 

示例 2：
> 输入：[2,2,2,0,1]
> 输出：0

- 方法1：二分查找。时间复杂度O(log(n)，空间复杂度O(1)。
  - 若n[mid] < n[r]，说明n[mid]是最小值右侧的元素，所以考虑左半区间。
  - 若n[mid] > n[r]，说明n[mid]是最小值左侧的元素，所以考虑右半区间。
  - 若n[mid] = n[r]，无法确定情况，但可以直接忽略区间的右端点。

```c++
class Solution {
public:
    int minArray(vector<int>& numbers) {
        int l = 0, r = numbers.size() - 1;

        while (l < r) {
            int mid = l + (r - l) / 2;
            if (numbers[mid] < numbers[r]) {
                r = mid;
            }
            else
            if (numbers[mid] > numbers[r]) {
                l = mid + 1;
            }
            else {
                r -= 1;
            }
        }

        return numbers[l];
    }
};
```

## 12. 矩阵中的路径★★

给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

示例 1：

> 输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
> 输出：true

示例 2：

> 输入：board = [["a","b"],["c","d"]], word = "abcd"
> 输出：false

- 方法1：DFS，时间复杂度O($3^k$ MN)，最差情况下，遍历字符串长度K的所有方案，时间复杂度为 O($3^k$ )；矩阵中共有 MN个起点，时间复杂度为 O(MN)。

  - 方案数计算： 设字符串长度为 K ，搜索中每个字符有上、下、左、右四个方向可以选择，舍弃回头（上个字符）的方向，剩下3 种选择，因此方案数的复杂度为 O($3^k$ )。

  空间复杂度O(K)，搜索递归深度不超过K。

```c++
class Solution {
private:
    int n, m;
    bool vis[205][205];
    bool dfs(vector<vector<char>>& board, string word, int x, int y, int k) {
        if(x >= n|| x < 0|| y >= m|| y < 0|| board[x][y] != word[k]|| vis[x][y]) {
            return false;
        }
        if(k == word.size() - 1) {
            return true;
        }
        vis[x][y] = true;
        bool res = dfs(board, word, x + 1, y, k + 1) || dfs(board, word, x - 1, y, k + 1) || dfs(board, word, x, y + 1, k + 1) || dfs(board, word, x , y - 1, k + 1);
        vis[x][y] = false;
        return res;
    }
public:
    bool exist(vector<vector<char>>& board, string word) {
        n = board.size();
        m = board[0].size();
        memset(vis, false, sizeof(vis));
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                if(dfs(board, word, i, j, 0)) {
                    return true;
                }
            }
        }
        return false;
    }
};
```

## 13. 机器人的运动范围

地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？

示例 1：

> 输入：m = 2, n = 3, k = 1
> 输出：3

示例 2：

> 输入：m = 3, n = 1, k = 0
> 输出：1

- 方法1：dfs，时间复杂度O(nm)，空间复杂度O(nm)。

```c++
class Solution {
private:
    bool vis[100][100];
    int n, m;
    int ans = 0;
    int f(int x, int y) {
        int ret = 0;
        while (x) {
            ret += x % 10;
            x /= 10;
        }
        while (y) {
            ret += y % 10;
            y /= 10;
        }
        return ret;
    }

    void dfs(int x, int y, int k) {
        if (x < 0 || x >= n || y < 0 || y >= m || vis[x][y] || f(x, y) > k) {
            return;
        }
        ans++;
        vis[x][y] = true;
        dfs(x + 1, y, k);dfs(x - 1, y, k);dfs(x, y + 1, k);dfs(x, y - 1, k);
    }
public:
    int movingCount(int row, int col, int k) {
        n = row;
        m = col;
        memset(vis, false, sizeof(vis));

        dfs(0, 0, k);
        return ans;
    }
};
```

## 14- I. 剪绳子★

给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]... *k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

示例 1：

> 输入: 2
> 输出: 1
> 解释: 2 = 1 + 1, 1 × 1 = 1

示例 2:

> 输入: 10
> 输出: 36
> 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36

- 方法1：贪心，找规律，发现尽可能多选择3。

```c++
class Solution {
public:
    int cuttingRope(int n) {
        if (n == 2) return 1;
        if (n == 3) return 2;

        int ans = 1;
        while (n > 4) {
            ans *= 3;
            n -= 3;
        }

        return ans * n;
    }
};
```

## 15. 二进制中1的个数★

编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数

示例 1：

> 输入：n = 11 (控制台输入 00000000000000000000000000001011)
> 输出：3
> 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。

示例 2：

> 输入：n = 128 (控制台输入 00000000000000000000000010000000)
> 输出：1
> 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。

示例 3：

> 输入：n = 4294967293 (控制台输入 11111111111111111111111111111101，部分语言中 n = -3）
> 输出：31
> 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。

- 方法1：使用左移操作循环检查，时间复杂度O(k)，k=32。空间复杂度O(1)。

```c++
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int ret = 0;
        for (int i = 0; i < 32; i++) {
            if (n & (1 << i)) {
                ret++;
            }
        }
        return ret;
    }
};
```

- 方法2：对于`n&(n−1)`，其运算结果把 n 的二进制位中的最低位的 1 变为 0 之后的结果。

- 如6 & (6-1)=4，6=110，4=100。

- 不断让当前的 n 与 n−1 做与运算，直到 n 变为 0 。

  每次运算会使得 n 的最低位的 1 被翻转，因此运算次数就等于 n 的二进制位中 1 的个数。

- 时间复杂度O（log n），最坏情况下就是n的二进制位全部为1，循环logn次，空间复杂度O（1）。

```c++
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int ret = 0;
        while (n) {
            n &= n - 1;
            ret++;
        }
        return ret;
    }
};
```

## 16. 数值的整数次方★

实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。

示例 1：

> 输入：x = 2.00000, n = 10
> 输出：1024.00000

- 方法1：快速幂，记得考虑负数情况。时间复杂度O（logn），空间复杂度O（1）。

```c++
class Solution {
public:
    double myPow(double x, long long n) {
        double ret = 1;

        if (n < 0) {
            n = -n;
            x = 1 / x;
        }

        while (n > 0) {
            if (n & 1) {
                ret *= x;
            }
            n >>= 1;
            x *= x;
        }

        return ret;
    }
};
```



## 17. 打印从1到最大的n位数★

输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。

示例 1:

> 输入: n = 1
> 输出: [1,2,3,4,5,6,7,8,9]



这题要考虑n的范围，如果n是一个非常大的数，即使long long 也会溢出，所以应该用字符串模拟数字，dfs遍历所有可能结果。

- 方法1：字符串模拟+dfs。

```c++
class Solution {
private:
    vector<int> nums;
    string s;
public:
    vector<int> printNumbers(int n) {
        s.resize(n, 0);
        dfs(n, 0);
        return nums;
    }

    void dfs(int end, int now) {
        if (now == end) {
            int i = 0;
            // 打印（存储）时去除开头0
            while (i < s.size() && s[i] == '0') {
                i++;
            }
            if (i != s.size()) {
                // 根据书上的题目，这里我们应该是直接打印字符串
                // cout << s.substr(i) << endl;
                nums.emplace_back(stoi(s.substr(i)));
            }
            return;
        }

        for (int i = 0; i <= 9; i++) {
            s[now] = i + '0';
            dfs(end, now + 1);
        }
    }
};
```

## 18. 删除链表的节点

给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

返回删除后的链表的头节点。

- 原文的意思是，给定一个链表中的节点，我们要删除这个节点。
  - 方法1是从头遍历，获取这个节点的上一个节点，但这需要O(n)时间复杂度。
  - 方法2是将下一个节点的内容复制到该节点，然后删除下一个节点，这样就只需要O(1)时间复杂度了。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* deleteNode(ListNode* head, int val) {
        auto dummyhead = new ListNode(0);
        dummyhead->next = head;
        auto cur = dummyhead;

        while (cur && cur->next) {
            if (cur->next->val == val) {
                cur->next = cur->next->next;
                break;
            }
            cur = cur->next;
        }

        return dummyhead->next;
    }
};
```



## 21. 调整数组顺序使奇数位于偶数前面

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

示例：

> 输入：nums = [1,2,3,4]
> 输出：[1,3,2,4] 
> 注：[3,1,2,4] 也是正确的答案之一。

- 方法1：头尾双指针

```c++
class Solution {
public:
    vector<int> exchange(vector<int>& nums) {
        for (int l = 0, r = nums.size() - 1; l < r;) {
            while (l < nums.size() && (nums[l] & 1) == 1) l++;
            while (r >= 0 && (nums[r] & 1) == 0) r--;
            if (l >= r) break;
            swap(nums[l++], nums[r--]);
        }
        return nums;
    }
};
```

- 方法2：快慢双指针

```c++
class Solution {
public:
    vector<int> exchange(vector<int>& nums) {
        int low = 0, fast = 0;
        while (fast < nums.size()) {
            if (nums[fast] & 1) {
                swap(nums[low], nums[fast]);
                low++;
            }
            fast++;
        }
        return nums;
    }
};
```

> 这题书上还要考虑可拓展性，应该吧判断条件写成函数形式作为参数。



## 22. 链表中倒数第k个节点★

输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。

例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。

- 方法1：快慢指针，**要充分考虑代码鲁棒性**，本题就有3个坑！

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* getKthFromEnd(ListNode* head, int k) {
        // 如果输入的是空指针或者k为0
        if (!head || k == 0) {
            return nullptr;
        }

        auto dummyhead = new ListNode(0);
        dummyhead->next = head;
        
        auto fast = dummyhead;
        for (int i = 0; i < k; i++) {
            fast = fast->next;
            // 如果链表的节点数比k还小
            if (!fast) {
                return nullptr;
            }
        }

        auto slow = dummyhead;
        while (fast) {
            fast = fast->next;
            slow = slow->next;
        }

        return slow;
    }
};
```



## 24. 反转链表★

定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

- 方法1：递归

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (!head || !head->next) {
            return head;
        }
        
        auto node = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;

        return node;
    }
};
```

- 方法2：迭代

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* pre = nullptr;
        ListNode* cur = head;
        ListNode* next = nullptr;

        while (cur) {
            // 存next
            next = cur->next;
            // 操作
            cur->next = pre;
            // pre、cur后移
            pre = cur;
            cur = next;
        }
        
        return pre;
    }
};
```



## 25. 合并两个排序的链表★★

输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。

**示例1：**

```
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
```

- 方法1：迭代

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        auto dummyhead = new ListNode(-1);
        auto pre = dummyhead;

        while (l1 && l2) {
            if (l1->val <= l2->val) {
                pre->next = l1;
                pre = pre->next;
                l1 = l1->next;
            }
            else {
                pre->next = l2;
                pre = pre->next;
                l2 = l2->next;
            }
        }

        if (l1) {
            pre->next = l1;
        }
        if (l2) {
            pre->next = l2;
        }

        return dummyhead->next;
    }
};
```

- 方法2，递归

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if (!l1) {
            return l2;
        }
        else
        if (!l2) {
            return l1;
        }

        if (l1->val <= l2->val) {
            l1->next = mergeTwoLists(l1->next, l2);
            return l1;
        }
        else {
            l2->next = mergeTwoLists(l2->next, l1);
            return l2;
        }
    }
};
```



## 26. 树的子结构★

输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)

B是A的子结构， 即 A中有出现和B相同的结构和节点值。

- 方法1：递归

```c++
class Solution { 
public:
    bool isSubStructure(TreeNode* A, TreeNode* B) {
        if (!A || !B) {
            return false;
        }
        return dfs(A, B) || isSubStructure(A->left, B) || isSubStructure(A->right, B);
    }
    bool dfs(TreeNode* A, TreeNode* B) {
        if (!B) {
            return true;
        }
        if (!A) {
            return false;
        }
        return A->val == B->val && dfs(A->left, B->left) && dfs(A->right, B->right);
    }
};
```



## 27. 二叉树的镜像

请完成一个函数，输入一个二叉树，该函数输出它的镜像。

- 方法1：递归

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* mirrorTree(TreeNode* root) {
        dfs(root);
        return root;
    }

    void dfs(TreeNode* root) {
        if (!root) {
            return;
        }
        auto tmp = root->left;
        root->left = root->right;
        root->right = tmp;
        dfs(root->left);
        dfs(root->right);
    }
};
```

## 28. 对称的二叉树

请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。

- 方法1：

  - 对称二叉树定义： 对于树中 **任意两个对称节点** L 和 R ，一定有：
    - L.val = R.val ：即此两对称节点值相等。
    - L.left.val = R.right.val ：即 L 的 左子节点 和 R 的 右子节点 对称；
    - L.right.val = R.left.val ：即 L 的 右子节点 和 R 的 左子节点 对称。

  或者也可以从遍历的角度出发，一颗对称二叉树的「中右左」遍历和「中左右」遍历（先序遍历）是一样。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        return dfs(root, root);
    }
    bool dfs(TreeNode* root1, TreeNode* root2) {
        if (!root1 && !root2) {
            return true;
        }
        if (!root1 || !root2) {
            return false;
        }
        if (root1->val != root2->val) {
            return false;
        }
        
        return dfs(root1->left, root2->right) && dfs(root1->right, root2->left);
    }
};
```

## 29. 顺时针打印矩阵★

输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。

- 方法1：模拟，写代码前先理清思路

```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> ret;
        if (matrix.empty()) {
            return ret;
        }

        int up = 0, down = matrix.size() - 1;
        int left = 0, right = matrix[0].size() -1;

        while (1) {
            for (int i = left; i <= right; i++) {
                ret.push_back(matrix[up][i]);
            }
            if (++up > down) break;

            for (int i = up; i <= down; i++) {
                ret.push_back(matrix[i][right]);
            }
            if (--right < left) break;

            for (int i = right; i >= left; i--) {
                ret.push_back(matrix[down][i]);
            }
            if (--down < up) break;

            for (int i = down; i >= up; i--) {
                ret.push_back(matrix[i][left]);
            }
            if (++left > right) break;
        }

        return ret;
    }
};
```



## 30. 包含min函数的栈

定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。

- 方法1：辅助栈，push一个元素的时候和当前栈顶元素对比，如果比栈顶元素小，那就push他自己，否则继续push栈顶元素。

  时间复杂度 O(1)： push(), pop(), top(), min() 四个函数的时间复杂度均为常数级别。
  空间复杂度 O(N) ： 当共有 N 个待入栈元素时，辅助栈 B 最差情况下存储 N 个元素，使用 O(N) 额外空间。

  

```c++
class MinStack {
public:
    stack <int> a;
    stack <int> b;
    /** initialize your data structure here. */
    MinStack() {

    }
    
    void push(int x) {
        a.push(x);
        // 记得考虑b为空的情况
        if (b.empty() || x < b.top()) {
            b.push(x);
        }
        else {
            b.push(b.top());
        }
    }
    
    void pop() {
        a.pop();
        b.pop();
    }
    
    int top() {
        return a.top();
    }
    
    int min() {
        return b.top();
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(x);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->min();
 */
```



## 31. 栈的压入、弹出序列

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。



- 方法1：压栈的元素按顺序压入，当栈顶元素和出栈的第一个元素相同，则将该元素弹出，出栈列表指针后移并继续判断。

  时间复杂度 O(N) ： 其中 N 为 pushed 的长度；每个元素最多入栈与出栈一次，即最多共 2N 次出入栈操作。
  空间复杂度 O(N) ： 辅助栈stack 最多同时存储 N 个元素。

  

```c++
class Solution {
public:
    bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {
        stack <int> s;
        int n = pushed.size();

        int j = 0;
        for (int i = 0; i < n; i++) {
            s.push(pushed[i]);
            while (!s.empty() && popped[j] == s.top()) {
                j++;
                s.pop();
            }
        }

        return j == n;
    }
};

```



## 32 - I. 从上到下打印二叉树

从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。

- 使用双端队列模拟层序遍历

  时间复杂度O(n)

  空间复杂度O(n)

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> levelOrder(TreeNode* root) {
        vector <int> ret;
        if (!root) {
            return ret;
        }

        deque <TreeNode*> dq;
        dq.push_back(root);
        while (!dq.empty()) {
            auto t = dq.front();
            dq.pop_front();
            ret.push_back(t->val);
            if (t->left) {
                dq.push_back(t->left);
            }
            if (t->right) {
                dq.push_back(t->right);
            }
        }

        return ret;
    }
};
```





## 32 - II. 从上到下打印二叉树 II ★

从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。

- `int size = q.size();` 实现分层输出层序遍历关键一步。

  复杂度同上题。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> ret;
        if (!root) {
            return ret;
        }

        queue <TreeNode*> q;
        q.push(root);
        while (!q.empty()) {
            vector<int> v;
            int size = q.size();
            while (size--) {
                auto node = q.front();
                q.pop();
                v.push_back(node->val);
                if (node->left) {
                    q.push(node->left);
                }
                if (node->right) {
                    q.push(node->right);
                }
            }
            ret.push_back(v);
        }

        return ret;

    }
};
```



## 33. 二叉搜索树的后序遍历序列★★

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 `true`，否则返回 `false`。假设输入的数组的任意两个数字都互不相同。

- 方法1：根据二叉搜索树的定义，可以通过递归，判断所有子树的 **正确性** （即其后序遍历是否满足二叉搜索树的定义） ，若所有子树都正确，则此序列为二叉搜索树的后序遍历。

  时间复杂度 O(N^2)： 每次调用dfs减去一个根节点，因此递归占用 O(N) ；最差情况下（即当树退化为链表），每轮递归都需遍历树所有节点，占用O(N) 。
  空间复杂度 O(N) ： 最差情况下（即当树退化为链表），递归深度将达到 N 。

  

```c++
class Solution {
public:
    bool verifyPostorder(vector<int>& postorder) {
        if (postorder.size() <= 1) {
            return true;
        }
        return verify(postorder, 0, postorder.size() - 1);
    }

    bool verify(vector<int> postorder, int l, int r) {
        // 若当前区域不合法，则返回true
        if (l >= r) {
            return true;
        }

        // 从当前区域找到第一个大于根节点的，说明后续区域数值都在右子树中
        int rootValue = postorder[r];
        int idx = l;
        while (idx < r && postorder[idx] < rootValue) {
            idx++;
        }

        // 进行判断后续的区域是否所有的值都是大于当前的根节点，如果出现小于的值就直接返回false
        for (int i = idx; i < r; i++) {
            if (postorder[i] < rootValue) {
                return false;
            }
        }

        // 当前树没问题就检查左右子树
        if (!verify(postorder, l, idx - 1)) {
            return false;
        }
        if (!verify(postorder, idx, r - 1)) {
            return false;
        }

        return true;
    }
};
```



## 34. 二叉树中和为某一值的路径

给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。

- 方法1：采用深度优先搜索的方式，枚举每一条从根节点到叶子节点的路径。当我们遍历到叶子节点，且此时路径和恰为目标和时，我们就找到了一条满足条件的路径。

  时间复杂度：O(N^2)，其中 N 是树的节点数。在最坏情况下，树的上半部分为链状，下半部分为完全二叉树，并且从根节点到每一个叶子节点的路径都符合题目要求。此时，路径的数目为O(N)，并且每一条路径的节点个数也为 O(N)，因此要将这些路径全部添加进答案中，时间复杂度为O(N^2)。

  空间复杂度：O(N)，空间复杂度主要取决于栈空间的开销，栈中的元素个数不会超过树的节点数。

  


```cpp
class Solution {
  public:
      vector <vector<int>> ret;
      vector <int> path;
  
      void dfs(TreeNode*root, int target) {
          if (!root) {
              return;
          }
  
          path.emplace_back(root->val);
          target -= root->val;
          // 若该节点为叶节点且满足题目条件(target == 0)
          if (!root->left && !root->right &&  target == 0) {
              ret.emplace_back(path);
          }
          dfs(root->left, target);
          dfs(root->right, target);
  
          path.pop_back();
      }
      
      vector<vector<int>> pathSum(TreeNode* root, int target) {
          dfs(root, target);
          return ret;
      }
  };
```

## 35. 复杂链表的复制

请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。



- 哈希表，时空复杂度都是O(n)

```cpp
class Solution {
public:
    map <Node*, Node*> mp;

    Node* copyRandomList(Node* head) {
        if (!head) {
            return head;
        }
        
        for (Node* cur = head; cur != nullptr; cur = cur->next) {
            mp[cur] = new Node(cur->val);
        }
        for (Node* cur = head; cur != nullptr; cur = cur->next) {
            mp[cur]->next = mp[cur->next];
            mp[cur]->random = mp[cur->random];
        }
        return mp[head];
    }
};
```

- 方法2：原地修改，时间复杂度O(n)，空间复杂度O(1)

```cpp
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if (!head) {
            return head;
        }
        
        //将拷贝节点放到原节点后面，例如1->2->3这样的链表就变成了1->1'->2->2'->3->3'
        for (auto node = head; node; node = node->next->next) {
            auto copy = new Node(node->val);
            copy->next = node->next;
            node->next = copy;
        }

        // 拷贝节点的random指针
        for (auto node = head; node; node = node->next->next) {
            if (node->random) {
                node->next->random = node->random->next;
            }
        }
        
        // 分离原节点和拷贝节点
        auto newHead = head->next;
        for (auto node = head; node && node->next; node->next) {
            auto temp = node->next;
            node->next = temp->next;
            node = temp;
        }

        return newHead;
    }
};
```



## 36. 二叉搜索树与双向链表

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

- 方法1：DFS

```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;

    Node() {}

    Node(int _val) {
        val = _val;
        left = NULL;
        right = NULL;
    }

    Node(int _val, Node* _left, Node* _right) {
        val = _val;
        left = _left;
        right = _right;
    }
};
*/
class Solution {
public:

    Node *pre, *head;

    Node* treeToDoublyList(Node* root) {
        if (!root) {
            return root;
        }
        // 中序遍历
        dfs(root);
        // 首尾相连
        head->left = pre;
        pre->right = head;
        return head;
    }

    void dfs(Node* node) {
        if (!node) {
            return;
        }
        dfs(node->left);
        
        // 若pre不为空,说明node为中间节点,pre保存的是上一个节点
        if (pre) pre->right = node;
        // 若pre为空，说明是第一个节点，用head来保存第一个结点
        else head = node;
        node->left = pre;
        pre = node;

        dfs(node->right);
    }
};		
```





## 37. 序列化二叉树

请实现两个函数，分别用来序列化和反序列化二叉树。

你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

- 方法1：层序遍历，时空复杂度都是O(n)

```cpp
class Codec {
public:
    
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        string data;
        queue <TreeNode*> q;
        if (root) {
            q.push(root);
        }

        while (!q.empty()) {
            auto cur = q.front();
            q.pop();

            if (cur) {
                data += to_string(cur->val) + ",";
                q.push(cur->left);
                q.push(cur->right);
            }
            else {
                data += "null,";
            }
        }

        if (!data.empty()) {
            data.pop_back();
        }
        return data;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        auto dummy = new TreeNode(0);
        queue <TreeNode*> q;
        q.push(dummy);
        int beg = 0, end = 0;
        bool left_side = false;

        while (beg < data.size()) {
            // 截取字符串
            while (end < data.size() && data[end] != ',') {
                end++;
            }
            auto str = data.substr(beg, end - beg);

            TreeNode* node = nullptr;
            if (str != "null") {
                // atoi是C语言中的函数,参数是字符指针char *,
                // c_str()的作用是将string转换为char *
                node = new TreeNode(atoi(str.c_str()));
            }

            auto cur = q.front();
            if (left_side) {
                cur->left = node;
            }
            else {
                cur->right = node;
                q.pop();
            }

            if (node) {
                q.push(node);
            }
            left_side = !left_side;
            beg = ++end;
        }

        return dummy->right;
    }
};

```

## 38. 字符串的排列

输入一个字符串，打印出该字符串中字符的所有排列。

你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。



```cpp
class Solution {
public:
    vector<string> permutation(string s) {
        vector <string> ret;
        
        sort(s.begin(), s.end());
        do {
            ret.emplace_back(s);
        } while (next_permutation(s.begin(), s.end()));

        return ret;
    }
};
```



## 39. 数组中出现次数超过一半的数字

数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

- 方法1：投票法，如果我们把众数记为 +1+1，把其他数记为 -1−1，将它们全部加起来，显然和大于 `0`，从结果本身我们可以看出众数比其他数多。

  时间复杂度O(n)，空间复杂度O(1)

```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int ret = 0, cnt = 0;
        for (auto num : nums) {
            if (cnt == 0) {
                ret = num;
                cnt++;
            }
            else {
                ret == num ? cnt++ : cnt--;
            }
        }

        return ret;
    }
};
```



## 40. 最小的k个数

输入整数数组 `arr` ，找出其中最小的 `k` 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。



- 方法1：大根堆，时间复杂度O(nlogk)，空间复杂度O(k)

```cpp
class Solution {
public:
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
        priority_queue <int > pq;
        vector<int> ret;

        if (k == 0) {
            return ret;
        }
        
        for (int x : arr) {
            if (pq.size() < k) {
                pq.push(x);
            }
            else {
                if (x < pq.top()) {
                    pq.pop();
                    pq.push(x);
                }
            }
        }
        
        while (!pq.empty()) {
            ret.push_back(pq.top());
            pq.pop();
        }

        return ret;
    }
};
```

- 方法2：快排，时间复杂度O(n)，最差O(n^2)，空间复杂度O(logn),最差O(n)

```cpp
class Solution {
public:
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
        if (k >= arr.size()) {
            return arr;
        }

        return quickSort(arr, k, 0, arr.size() - 1);
    }

    vector <int> quickSort(vector<int> arr, int k, int l, int r) {
        int i = l, j = r;

        while (i < j) {
            while (i < j && arr[j] >= arr[l]) j--;
            while (i < j && arr[i] <= arr[l]) i++;
            swap(arr[i], arr[j]);
        }
        swap(arr[i], arr[l]);

        if (i > k) {
            return quickSort(arr, k, l, i - 1);
        }
        if (i < k) {
            return quickSort(arr, k, i + 1, r);
        }

        vector <int> ans;
        ans.assign(arr.begin(), arr.begin() + k);
        return ans;

    }
};
```



## 41. 数据流中的中位数

如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。

例如，

[2,3,4] 的中位数是 3

[2,3] 的中位数是 (2 + 3) / 2 = 2.5

设计一个支持以下两种操作的数据结构：

void addNum(int num) - 从数据流中添加一个整数到数据结构中。
double findMedian() - 返回目前所有元素的中位数。

- 方法1：大根堆加小根堆分别存储左半部分和右半部分。

  时间复杂度O(logn) 空间复杂度O(n)

```cpp
class MedianFinder {
public:
    // 最大堆，存储左边一半的数据，堆顶为最大值
    priority_queue<int, vector<int>, less<int>> maxHeap;
    // 最小堆， 存储右边一半的数据，堆顶为最小值
    priority_queue<int, vector<int>, greater<int>> minHeap;
    /** initialize your data structure here. */
    MedianFinder() {
    }

    // 维持堆数据平衡，并保证左边堆的最大值小于或等于右边堆的最小值
    void addNum(int num) {
        /*
         * 当两堆的数据个数相等时候，左边堆添加元素。
         * 采用的方法不是直接将数据插入左边堆，而是将数据先插入右边堆，算法调整后
         * 将堆顶的数据插入到左边堆，这样保证左边堆插入的元素始终是右边堆的最小值。
         * 同理左边数据多，往右边堆添加数据的时候，先将数据放入左边堆，选出最大值放到右边堆中。
         */
        if (maxHeap.size() == minHeap.size()) {
            minHeap.push(num);
            maxHeap.push(minHeap.top());
            minHeap.pop();
        } else {
            maxHeap.push(num);
            minHeap.push(maxHeap.top());
            maxHeap.pop();
        }
    }
    
    double findMedian() {
        if (maxHeap.size() == minHeap.size()) {
            return (maxHeap.top()+minHeap.top())*1.0/2;
        } else {
            return maxHeap.top()*1.0;
        }
    }
};
```





## 42. 连续子数组的最大和

输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

要求时间复杂度为O(n)。

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int sum = 0;
        int ans = -INT_MAX;

        for (int num : nums) {
            if (sum <= 0) {
                sum = num;
            }
            else {
                sum += num;
            }
            
            ans = max(ans, sum);
        }

        return ans;
    }
};
```





## 43. 1～n 整数中 1 出现的次数★★★

输入一个整数 `n` ，求1～n这n个整数的十进制表示中1出现的次数。

- 方法1：数位dp，详细看题解 https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/

```cpp
class Solution {
public:
    int countDigitOne(int n) {
        int ans = 0;

        for (long long mulk = 1; n >= mulk; mulk *= 10) {
            ans += (n /(mulk * 10)) * mulk + min(max(0LL, n % (mulk * 10) - mulk + 1), mulk);
        }

        return ans;
    }
};
```





## 44. 数字序列中某一位的数字★★

数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。

请写一个函数，求任意第n位对应的数字。

- 找规律

```cpp
/* 数字范围    数量  位数    占多少位
    1-9        9      1       9
    10-99      90     2       180
    100-999    900    3       2700
    1000-9999  9000   4       36000  ...

    例如 2901 = 9 + 180 + 2700 + 12 即一定是4位数,第12位   n = 12;
    数据为 = 1000 + (12 - 1)/ 4  = 1000 + 2 = 1002
    定位1002中的位置 = (n - 1) %  4 = 3    s.charAt(3) = 2;
*/


class Solution {
public:
    int findNthDigit(int n) {
        // n所在数字的位数
        int digit = 1;
        // 数字范围开始的第一个数
        long long start = 1;
        // 占多少位
        long long count = 9;

        while (n > count) {
            n -= count;
            digit++;
            start *= 10;
            count = digit * start * 9;
        }

        // 定位
        long long num = start + (n - 1) / digit;
        int ret = to_string(num)[(n - 1) % digit] - '0';

        return ret;
    }
};
```







## 45. 把数组排成最小的数

输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。

```cpp
class Solution {
public:

    static bool cmp(string x, string y) {
        // 关键，当x为21，y为2时，如果直接x < y会得到false，导致y放在x前面
        // 采用x + y < y + x， 212 < 221， 因此得到true，x能正确地放在y前面
        return x + y < y + x;
    }


    string minNumber(vector<int>& nums) {

        vector <string> strs;
        for (int num : nums) {
            strs.push_back(to_string(num));
        }
        sort(strs.begin(), strs.end(), cmp);
        
        string ans = "";
        for (string str : strs) {
            ans += str;
        }

        return ans;
    }
};

```





## 46. 把数字翻译成字符串★

给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。



- 方法1：DFS

```cpp
class Solution {
public:
    int translateNum(int num) {
        if (num <= 9) {
            return 1;
        }

        int MOD = num % 100;
        if (MOD <= 9 || MOD >= 26) {
            return translateNum(num / 10);
        }
        else {
            return translateNum(num / 10) + translateNum(num / 100);
        }
    }
};
```



- 方法2：DP，青蛙跳台阶

```cpp
class Solution {
public:
    int translateNum(int num) {
        string str = to_string(num);
        int len = str.size();
        vector <int> dp = vector<int>(len + 1, 1);

        for (int i = 2; i <= len; i++) {
            if (str[i - 2] == '1' || str[i - 2] == '2' && str[i - 1] <= '5') {
                dp[i] = dp[i - 2] + dp[i - 1];
            }
            else {
                dp[i] = dp[i - 1];
            }
        }

        return dp[len];
    }
};
```



## 47. 礼物的最大价值

在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？

- 方法1：DP

```cpp
class Solution {
public:
    int maxValue(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();

        for (int i = 1; i < n; i++) {
            grid[i][0] += grid[i - 1][0];
        }
        for (int j = 1; j < m; j++) {
            grid[0][j] += grid[0][j - 1];
        }

        for (int i = 1; i < n; i++) {
            for (int j = 1; j < m; j++) {
                grid[i][j] += max(grid[i - 1][j], grid[i][j - 1]);
            }
        }

        return grid[n - 1][m - 1];
    }
};
```



## 48. 最长不含重复字符的子字符串

请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。

- 方法1：双指针

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int n = s.size();
        unordered_set <char> st;

        int ans = 0;
        int r = -1;

        for (int l = 0; l < n; l++) {
            if (l != 0) {
                st.erase(s[l - 1]);
            }
            while (r + 1 < n && !st.count(s[r + 1])) {
                st.insert(s[++r]);
            }
            ans = max(ans, r - l + 1);
        }

        return ans;
    }
};
```





## 49. 丑数★

我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。

- 动态规划，时间复杂度O(n)，空间复杂度O(1)

```cpp
class Solution {
public:
    int nthUglyNumber(int n) {
        int n2 = 0, n3 = 0, n5 = 0;
        vector <int> dp(n);

        dp[0] = 1;
        for (int i = 1; i < n; i++) {
            dp[i] = min(2 * dp[n2], min(3 * dp[n3], 5 * dp[n5]));
            if(dp[i] == 2*dp[n2]) n2++;
            if(dp[i] == 3*dp[n3]) n3++;
            if(dp[i] == 5*dp[n5]) n5++;
        }

        return dp[n - 1];
    }
};
```

## 50. 第一个只出现一次的字符

在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。

- 方法1：哈希表，时间复杂度O(n) O空间复杂度O(T) , T是字符集大小

```cpp
class Solution {
public:
    char firstUniqChar(string s) {
        if (s.size() == 0) {
            return ' ';
        }

        map <char, int> mp;

        for (char ch : s) {
            mp[ch]++;
        }
        for (char ch : s) {
            if (mp[ch] == 1) {
                return ch;
            }
        }

        return ' ';
    }
};
```

## 51. 数组中的逆序对★★★

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

- 方法1：归并排序，时间复杂度O(nlogn)，空间复杂度O(n)，

  详细题解https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/shu-zu-zhong-de-ni-xu-dui-by-leetcode-solution/

```cpp
class Solution {
public:
    int mergeSort(vector<int>& nums, vector<int>& tmp, int l, int r) {
        if (l >= r) {
            return 0;
        }

        int mid = (l + r) / 2;
        int inv_count = mergeSort(nums, tmp, l, mid) + mergeSort(nums, tmp, mid + 1, r);
        int i = l, j = mid + 1, pos = l;
        while (i <= mid && j <= r) {
            if (nums[i] <= nums[j]) {
                tmp[pos++] = nums[i++];
                inv_count += j - (mid + 1);
            }
            else {
                tmp[pos++] = nums[j++];
            }
        }
        for (int k = i; k <= mid; ++k) {
            tmp[pos++] = nums[k];
            inv_count += j - (mid + 1);
        }
        for (int k = j; k <= r; ++k) {
            tmp[pos++] = nums[k];
        }
        copy(tmp.begin() + l, tmp.begin() + r + 1, nums.begin() + l);
        return inv_count;
    }

    int reversePairs(vector<int>& nums) {
        int n = nums.size();
        vector<int> tmp(n);
        return mergeSort(nums, tmp, 0, n - 1);
    }
};

```



## 52. 两个链表的第一个公共节点★★

输入两个链表，找出它们的第一个公共节点。

- 方法1：当链表$ \textit{headA} $和 $\textit{headB} $ 都不为空时，创建两个指针 $\textit{pA}$ 和 $\textit{pB}$，初始时分别指向两个链表的头节点$ \textit{headA}$ 和$ \textit{headB}$，然后将两个指针依次遍历两个链表的每个节点。时间复杂度O（n+m），分别为两个链表的长度，空间复杂度O（1）。

  

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        auto pA = headA;
        auto pB = headB;

        while (pA != pB) {
            pA = pA ? pA->next : headB;
            pB = pB ? pB->next : headA;
        }

        return pA;
    }
};
```





## 53 - 在排序数组中查找数字 I ★

统计一个数字在排序数组中出现的次数。

- 二分，时间复杂度O(logn)，空间复杂度O(1)

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = nums.size();
        if (n == 0) {
            return 0;
        }

        int l, r, mid;

        // left
        l = 0, r = n - 1;
        while (l < r) {
            mid = l + (r - l) / 2;
            if (nums[mid] >= target) {
                r = mid;
            }
            else {
                l = mid + 1;
            }
        }
        int posL = nums[l] == target ? l : 0;


        // right
        l = 0, r = n - 1;
        while (l < r) {
            mid = l + (r - l) / 2;
            if (nums[mid] <= target) {
                l = mid;
            }
            else {
                r = mid - 1;
            }
        }
        int posR = nums[l] == target ? l : 0;

        return posR - posL;
    }
};
```



## 53 - 0～n-1中缺失的数字★★

一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。

 

- 二分，时间复杂度O(logn), 空间复杂度O(1)
- 两种二分方法都ok

```cpp
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int l = 0, r = nums.size() - 1;
        while (l <= r) {
            int mid = (l + r) / 2;
            if (nums[mid] == mid) {
                l = mid + 1;
            }
            else {
                r = mid - 1;
            }
        }
        return l;
    }
};
```

```cpp
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int l = 0, r = nums.size() - 1;
        while (l < r) {
            int mid = (l + r) / 2;
            if (nums[mid] == mid) {
                l = mid + 1;
            }
            else {
                r = mid;
            }
        }
        return l == nums[l] ? l + 1 : l;
    }
};
```

## 54. 二叉搜索树的第k大节点

给定一棵二叉搜索树，请找出其中第k大的节点。

- 方法1：后序遍历，提前返回。时间复杂度O(n)，空间复杂度O(n)

``` cpp

class Solution {
public: 
    int res;
    int k;
    int kthLargest(TreeNode* root, int k) {
        this->k = k;
        dfs(root);
        return res;
    }
    void dfs(TreeNode* root)
    {
        if(!root) return;
        dfs(root->right);
        k--;
        if(k == 0) res = root->val;
        dfs(root->left);
    }
};

```

## 55 - 二叉树的深度

输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。

- dfs

```cpp
class Solution {
public:
    int depth = 0;

    void dfs(TreeNode* node, int cnt) {
        if (!node) {
            return;
        }

        if (!node->left && !node->right) {
            depth = max(depth, cnt);
            return;
        }

        dfs(node->left, cnt + 1);
        dfs(node->right, cnt + 1);

    }

    int maxDepth(TreeNode* root) {
        dfs(root, 1);
        return depth;
    }
};
```

## 55 - 平衡二叉树

- dfs

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:

    bool ret = true;

    int dfs(TreeNode* node) {
        if (!node) {
            return 0;
        }

        int ld = dfs(node->left);
        int rd = dfs(node->right);

        if (abs(ld - rd) > 1) {
            ret = false;
        }

        return max(ld, rd) + 1;
    }
    bool isBalanced(TreeNode* root) {
        dfs(root);
        return ret;
    }
};
```







## 56 - 数组中数字出现的次数★★★

一个整型数组 `nums` 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

- 位运算

``` cpp
class Solution {
public:
    vector<int> singleNumbers(vector<int>& nums) {
        // 任何数 ^ 0 是它本身
        // x 用来记录 a b 的异或结果
        int x = 0;

        // 本题中，所有数字异或的结果即 a ^ b
        for (int num : nums) {
            x ^= num;
        }

        // xi = 1 表示ai 和 bi不等
        // x & (-x) 保留二进制下最后出现的1的位置，其余位置置0
        int flag = x & (-x);

        // 利用这个1进行分组，将a和b区分开
        // x是A和B相异或的结果，因此，x的二进制串上的任何一个1，都能成为区分A和B的条件

        // 记录a或者b
        int res = 0;
        for (int num : nums) {
            // 根据最后一位1进行分组，无论如何，除了a和b，相同的数总会分在同一组
            // 因此把同一组的数直接进行异或，res肯定是a或者b
            if ( (flag & num) != 0) {
                res ^= num;
            }
        }

        vector <int> ret;
        ret.emplace_back(res);
        // 利用异或运算的自反性，x = a ^ b
        // 如果res为a， 那b 就是 x ^ res
        ret.emplace_back(x ^ res);

        return ret;
    }
};
```

## 56 - 数组中数字出现的次数 II

在一个数组 `nums` 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。

 

- 遍历所有数字，统计每个数字在二进制下的每一位。
- 求最终结果时，对每一位mod3，再转换成十进制可以得到答案
- 时间复杂度O(n)，空间复杂度O(1)

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        vector <int> count(32, 0);

        for (int num : nums) {
            int idx = 0;
            while (num) {
                int flag = num & 1;
                count[idx++] += flag;
                num = num >> 1;
            }
        }

        for (int i = 0; i < 32; i++) {
            count[i] %= 3;
        }

        int ret = 0;
        for (int i = 31; i >= 0; i--) {
            ret = ret * 2 + count[i];
        }

        return ret;
    }
};
```

## 57. 和为s的两个数字

输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。

- 方法1：哈希表，1次遍历，时间复杂度O(N)，空间复杂度O(N)

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector <int> ret;
        map <int, int> mp;

        for (int num : nums) {
            if (num < target) {
                mp[num]++;
            }
        }

        for (auto it = mp.begin(); it != mp.end(); it++) {
            if (it->second >= 1 && mp[target - it->first] >= 1) {
                ret.push_back(it->first);
                ret.push_back(target - it->first);
                break;
            }
        }
        return ret;
    }
};
```

- 方法2，双指针，注意本题是 **排序数组** ，因此可使用 **双指针法** 将空间复杂度降低至 O(1) 。

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int l = 0, r = nums.size() - 1;
        vector<int> ans;

        while (l < r) {
            int sum = nums[l] + nums[r];
            if (sum < target) {
                l++;
            }
            else
            if (sum > target) {
                r--;
            }
            else  {
                ans.push_back(nums[l]);
                ans.push_back(nums[r]);
                return ans;
            }
        }
        return ans;
    }
};
```

## 57 - II. 和为s的连续正数序列

输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。

序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。

- 方法1：滑动窗口，时间复杂度O（n）,空间复杂度O(1)

```cpp
class Solution {
public:
    vector<vector<int>> findContinuousSequence(int target) {
        vector<vector<int>> ans;
        
        int sum = 0;
        for (int l = 1, r = 1; r < target; r++) {
            sum += r;
            while (sum > target) {
                sum -= l++;
            }
            if (sum == target) {
                vector<int> temp;
                for (int i = l; i <= r; i++) {
                    temp.push_back(i);
                }
                ans.push_back(temp);
            }
        }
        return ans;
    }
};
```



## 58 - I. 翻转单词顺序

输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串"I am a student. "，则输出"student. a am I"。

- 方法1：双指针，时间复杂度O(N),空间复杂度O(N)

```cpp
class Solution {
public:
    string reverseWords(string s) {
        string ans = "";

        int n = s.size();
        if (n == 0) {
            return ans;
        }

        int r = n - 1;
        while (r >= 0) {
            while (r >= 0 && s[r] == ' ') {
                r--;
            }
            if (r < 0) {
                break;
            }

            int l = r;
            while (l >= 0 && s[l] != ' ') {
                l--;
            }

            ans += s.substr(l + 1, r - l);
            ans += " ";

            r = l;
        }

        if (!ans.empty()) {
            ans.pop_back();
        }

        return ans;

    }
};
```

## 58 - II. 左旋转字符串

字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。

```cpp
class Solution {
public:
    string reverseLeftWords(string s, int n) {
        int len = s.size();

        string s1 = s.substr(0, n);
        string s2 = s.substr(n);

        string ans = s2 + s1;

        return ans;
    }
};
```



## 59 - I. 滑动窗口的最大值★★

给定一个数组 `nums` 和滑动窗口的大小 `k`，请找出所有滑动窗口里的最大值。

- 单调队列，使用一个队列存储所有还没有被移除的下标。在队列中，这些下标按照从小到大的顺序被存储，并且它们在数组nums 中对应的值是严格单调递减的。时间复杂度O(n）,空间复杂度O(n)

```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int n = nums.size();
        deque <int> dq;
        vector <int> ans;

        if (n == 0) {
            return ans;
        }

        for (int i = 0; i < n; i++) {
            // 正常移动
            while (!dq.empty() && i - dq.front() > k - 1) {
                dq.pop_front();
            }
            // 维护单调队列，保证front()都是最大的
            while (!dq.empty() && nums[dq.back()] < nums[i]) {
                dq.pop_back();
            }
            dq.push_back(i);
            if (i >= k - 1) {
                ans.push_back(nums[dq.front()]);
            }
        }

        return ans;
    }
};
```

## 59 - II. 队列的最大值★

请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。

若队列为空，pop_front 和 max_value 需要返回 -1

- 方法同上，但上一题因为输入的数组，所以单调队列维护的是下标，这题直接输入值，所以单调队列就直接维护值了。时间复杂度O(1）,空间复杂度O(n)

```cpp
class MaxQueue {
public:
    queue <int> q;
    deque <int> dq;
    MaxQueue() {
    }
    
    int max_value() {
        if (q.empty()) {
            return -1;
        }

        return dq.front();
    }
    
    void push_back(int value) {
        while (!dq.empty() && dq.back() < value) {
            dq.pop_back();
        }
        dq.push_back(value);
        q.push(value);
    }
    
    int pop_front() {
        if (q.empty()) {
            return -1;
        }

        int ret = q.front();
        if (q.front() == dq.front()) {
            dq.pop_front();
        }
        q.pop();
        return ret;
    }
};

```

## 60. n个骰子的点数★

把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。

- dp，从一个筛子开始往后传播，具体看https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/solution/jian-zhi-offer-60-n-ge-tou-zi-de-dian-sh-z36d/
- 时间复杂度O(n2)，空间复杂度O(n)

```cpp
class Solution {
public:
    vector<double> dicesProbability(int n) {
        vector <double> dp(6, 1.0 / 6.0);

        for (int i = 2; i <= n; i++) {
            // 6 * i - (i - 1)表示i个筛子时的点数之和范围
            // 比如两个筛子时，最大为12，最小为2，总共 2*6 - (2 - 1)种和
            vector <double> temp(6 * i - (i - 1), 0);

            for (int j = 0; j < dp.size(); j++) {
                for (int k = 0; k < 6; k++) {
                    temp[j + k] += dp[j] * (1.0 / 6.0);
                }
            }
            dp = temp;
        }

        return dp;
    }
};
```

## 61. 扑克牌中的顺子

从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。

- 模拟，两种思路，最大-最小<5，或者不同牌之间差值<5

```cpp
class Solution {
public:
    bool isStraight(vector<int>& nums) {
        sort(nums.begin(), nums.end());

        int temp = 0;
        for (int i = 1; i < 5; i++) {
            if (nums[i - 1] == 0) {
                continue;
            }
            if (nums[i] == nums[i - 1]) {
                return false;
            }
            temp += nums[i] - nums[i - 1];
        }

        return temp < 5;
    }
};
```



