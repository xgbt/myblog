---
title: "剑指Offer"
date: 2021-07-09T14:28:20+08:00
draft: false
tags: [算法]
categories: [笔记]
---



## 03. 数组中重复的数字★

在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

示例 1：

> 输入：
> [2, 3, 1, 0, 2, 5, 3]
> 输出：2 或 3 


限制：2 <= n <= 100000

- 方法1：哈希表，时间复杂度O(n)，空间复杂度O(n)

```c++
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        unordered_map <int, int> mp;
        for (int num : nums) {
            if (mp[num] == 1) {
                return num;
            }
            mp[num]++;
        }
        return -1;
    }
};
```

- 方法2：排序，时间复杂度O(nlogn)，空间复杂度O(1)

```c++
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size() - 1; i++) {
            if (nums[i] == nums[i + 1]) {
                return nums[i];
            }
        }
        return -1;
    }
};
```

- 方法3：题目中提到 「在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内」，利用这个条件，遍历数组并通过交换操作，使元素的索引与值 一一对应，时间复杂度O(n)，空间复杂度O(1)。

```c++
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] == i) {
                continue;
            }
            if (nums[i] == nums[nums[i]]) {
                return nums[i];
            }
            swap(nums[i], nums[nums[i]]);
        }
        
        return -1;
    }
};
```



## 04. 二维数组中的查找★

在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

示例: 现有矩阵 matrix 如下：

> [
>   [1,   4,  7, 11, 15],
>   [2,   5,  8, 12, 19],
>   [3,   6,  9, 16, 22],
>   [10, 13, 14, 17, 24],
>   [18, 21, 23, 26, 30]
> ]

给定 target = 5，返回 true。

给定 target = 20，返回 false。

限制：

0 <= n <= 1000

0 <= m <= 1000

- 方法1：利用题目条件，从右上角元素出发，如果target大于该元素则往下移动，如果target小于该元素则向左移动，时间复杂度O(nm)，空间复杂度O(1)。

```c++
class Solution {
public:
    bool findNumberIn2DArray(vector<vector<int>>& matrix, int target) {
        if (matrix.size() == 0 || matrix[0].size() == 0) {
            return false;
        }
        
        int n = matrix.size();
        int m = matrix[0].size();
        int x = 0, y = m - 1;
        while (x < n && y >= 0) {
            if (target < matrix[x][y]) {
                y--;
            }
            else 
            if (target > matrix[x][y]) {
                x++;
            }
            else {
                return true;
            }
        }

        return false;
    }
};
```



## 05. 替换空格

实现一个函数，把字符串 s 中的每个空格替换成"%20"。

示例 1：

> 输入：s = "We are happy."
> 输出："We%20are%20happy."


限制：

0 <= s 的长度 <= 10000

- 方法1：遍历字符串s，时间复杂度O(n)，空间复杂度O(n)。

```c++
class Solution {
public:
    string replaceSpace(string s) {
        string ans = "";
        for (char ch : s) {
            if (ch == ' ') {
                ans += "%20";
            }
            else {
                ans += ch;
            }
        }
        return ans;
    }
};
```



## 06. 从尾到头打印链表★

输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。

示例 1：

> 输入：head = [1,3,2]
> 输出：[2,3,1]


限制：

0 <= 链表长度 <= 10000

- 方法1：递归，时间复杂度O(n)，空间复杂度O(n)。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> ans;

    void reCursion(ListNode* head) {
        if (head == nullptr) {
            return;
        }
        reCursion(head->next);
        ans.emplace_back(head->val);
    }
    
    vector<int> reversePrint(ListNode* head) {
        reCursion(head);
        return ans;
    }
};
```

- 方法2：栈，时间复杂度O(n)，空间复杂度O(n)。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> reversePrint(ListNode* head) {
        stack<int> stk;
        vector<int> ans;

        while (head) {
            stk.push(head->val);
            head = head->next;
        } 
        while (!stk.empty()) {
            ans.push_back(stk.top());
            stk.pop();
        }

        return ans;
    }
};
```



## 07. 重建二叉树★

输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

- 方法1：递归，时间复杂度O(n)，空间复杂度O(n)，除去返回的答案需要的O(n) 空间之外，我们还需要使用O(n) 的空间存储哈希映射，以及O(h)（其中 h 是树的高度）的空间表示递归时栈空间。这里h<n，所以总空间复杂度为 O(n)。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
private:
    unordered_map <int, int> mp;
public:
    TreeNode* myBuildTree(vector<int> preorder, vector<int> inorder, int pre_left, int pre_right, int in_left, int in_right) {
        if (pre_left > pre_right) {
            return nullptr;
        }

        // 前序遍历中的第一个节点是根节点,在中序遍历中进行定位
        int in_root = mp[preorder[pre_left]];
        // 构造根节点
        TreeNode* root = new TreeNode(preorder[pre_left]);
        // 求左子树的长度方便计算
        int len = in_root - in_left;
        root->left = myBuildTree(preorder, inorder, pre_left + 1, pre_left + len, in_left, in_root - 1);
        root->right = myBuildTree(preorder, inorder, pre_left + len + 1, pre_right, in_root + 1, in_right);

        return root;
    }

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        for (int i = 0; i < preorder.size(); i++) {
            mp[inorder[i]] = i;
        }

        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);
    }
};
```

- 方法2：迭代，时间复杂度O(n)，空间复杂度O(n)，太麻烦了。

``` c++
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if (!preorder.size()) {
            return nullptr;
        }
        TreeNode* root = new TreeNode(preorder[0]);
        stack<TreeNode*> stk;
        stk.push(root);
        int inorderIndex = 0;
        for (int i = 1; i < preorder.size(); ++i) {
            int preorderVal = preorder[i];
            TreeNode* node = stk.top();
            if (node->val != inorder[inorderIndex]) {
                node->left = new TreeNode(preorderVal);
                stk.push(node->left);
            }
            else {
                while (!stk.empty() && stk.top()->val == inorder[inorderIndex]) {
                    node = stk.top();
                    stk.pop();
                    ++inorderIndex;
                }
                node->right = new TreeNode(preorderVal);
                stk.push(node->right);
            }
        }
        return root;
    }
};
/*
作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
*/
```





## 09. 用两个栈实现队列

用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 `appendTail` 和 `deleteHead` ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，`deleteHead` 操作返回 -1 )

- 方法1：模拟，时间复杂度O(1)，空间复杂度O(n)。

```c++
class CQueue {
public:

    stack<int> s1;
    stack<int> s2;

    CQueue() {
        while (!s1.empty()) {
            s1.pop();
        }
        while (!s2.empty()) {
            s2.pop();
        }
    }
    
    void appendTail(int value) {
        s1.push(value);
    }
    
    int deleteHead() {
        if (s2.empty()) {
            while(!s1.empty()) {
                s2.push(s1.top());
                s1.pop();
            }
        }

        if (s2.empty()) {
            return -1;
        }
        else {
            int ret = s2.top();
            s2.pop();
            return ret;
        }
    }
};

/**
 * Your CQueue object will be instantiated and called as such:
 * CQueue* obj = new CQueue();
 * obj->appendTail(value);
 * int param_2 = obj->deleteHead();
 */
```

## 10- I. 斐波那契数列

写一个函数，输入 `n` ，求斐波那契（Fibonacci）数列的第 `n` 项（即 `F(N)`）

- 方法1：dp，时间复杂度O(n)，空间复杂度O(n)。

```c++
#define MOD 1000000007
class Solution {
public:
    map <int, int> mp;
    int fib(int n) {
        mp[0] = 0;
        mp[1] = 1;
        for (int i = 2; i <= n; i++) {
            mp[i] = mp[i - 1] + mp[i - 2];
            mp[i] %= MOD;
        }

        return mp[n];
    }
};
```

## 10- II. 青蛙跳台阶问题

一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 `n` 级的台阶总共有多少种跳法。

青蛙跳台阶问题： `f(0)=1 , f(1)=1 , f(2)=2 ；
斐波那契数列问题： f(0)=0 , f(1)=1 , f(2)=1 。

```c++
#define MOD 1000000007
class Solution {
public:
    int numWays(int n) {
        map <int, int> mp;
        mp[0] = 1;
        mp[1] = 1;
        for (int i = 2; i <= n; i++) {
            mp[i] = mp[i - 1] + mp[i - 2];
            mp[i] %= MOD;
        }

        return mp[n];
    }
};
```



## 11. 旋转数组的最小数字★★

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  

示例 1：

> 输入：[3,4,5,1,2]
> 输出：1 

示例 2：
> 输入：[2,2,2,0,1]
> 输出：0

- 方法1：二分查找。时间复杂度O(log(n)，空间复杂度O(1)。
  - 若n[mid] < n[r]，说明n[mid]是最小值右侧的元素，所以考虑左半区间。
  - 若n[mid] > n[r]，说明n[mid]是最小值左侧的元素，所以考虑右半区间。
  - 若n[mid] = n[r]，无法确定情况，但可以直接忽略区间的右端点。

```c++
class Solution {
public:
    int minArray(vector<int>& numbers) {
        int l = 0, r = numbers.size() - 1;

        while (l < r) {
            int mid = l + (r - l) / 2;
            if (numbers[mid] < numbers[r]) {
                r = mid;
            }
            else
            if (numbers[mid] > numbers[r]) {
                l = mid + 1;
            }
            else {
                r -= 1;
            }
        }

        return numbers[l];
    }
};
```

## 12. 矩阵中的路径★★

给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

示例 1：

> 输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
> 输出：true

示例 2：

> 输入：board = [["a","b"],["c","d"]], word = "abcd"
> 输出：false

- 方法1：DFS，时间复杂度O($3^k$ MN)，最差情况下，遍历字符串长度K的所有方案，时间复杂度为 O($3^k$ )；矩阵中共有 MN个起点，时间复杂度为 O(MN)。

  - 方案数计算： 设字符串长度为 K ，搜索中每个字符有上、下、左、右四个方向可以选择，舍弃回头（上个字符）的方向，剩下3 种选择，因此方案数的复杂度为 O($3^k$ )。

  空间复杂度O(K)，搜索递归深度不超过K。

```c++
class Solution {
private:
    int n, m;
    bool vis[205][205];
    bool dfs(vector<vector<char>>& board, string word, int x, int y, int k) {
        if(x >= n|| x < 0|| y >= m|| y < 0|| board[x][y] != word[k]|| vis[x][y]) {
            return false;
        }
        if(k == word.size() - 1) {
            return true;
        }
        vis[x][y] = true;
        bool res = dfs(board, word, x + 1, y, k + 1) || dfs(board, word, x - 1, y, k + 1) || dfs(board, word, x, y + 1, k + 1) || dfs(board, word, x , y - 1, k + 1);
        vis[x][y] = false;
        return res;
    }
public:
    bool exist(vector<vector<char>>& board, string word) {
        n = board.size();
        m = board[0].size();
        memset(vis, false, sizeof(vis));
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                if(dfs(board, word, i, j, 0)) {
                    return true;
                }
            }
        }
        return false;
    }
};
```

## 13. 机器人的运动范围

地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？

示例 1：

> 输入：m = 2, n = 3, k = 1
> 输出：3

示例 2：

> 输入：m = 3, n = 1, k = 0
> 输出：1

- 方法1：dfs，时间复杂度O(nm)，空间复杂度O(nm)。

```c++
class Solution {
private:
    bool vis[100][100];
    int n, m;
    int ans = 0;
    int f(int x, int y) {
        int ret = 0;
        while (x) {
            ret += x % 10;
            x /= 10;
        }
        while (y) {
            ret += y % 10;
            y /= 10;
        }
        return ret;
    }

    void dfs(int x, int y, int k) {
        if (x < 0 || x >= n || y < 0 || y >= m || vis[x][y] || f(x, y) > k) {
            return;
        }
        ans++;
        vis[x][y] = true;
        dfs(x + 1, y, k);dfs(x - 1, y, k);dfs(x, y + 1, k);dfs(x, y - 1, k);
    }
public:
    int movingCount(int row, int col, int k) {
        n = row;
        m = col;
        memset(vis, false, sizeof(vis));

        dfs(0, 0, k);
        return ans;
    }
};
```

## 14- I. 剪绳子★

给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]... *k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

示例 1：

> 输入: 2
> 输出: 1
> 解释: 2 = 1 + 1, 1 × 1 = 1

示例 2:

> 输入: 10
> 输出: 36
> 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36

- 方法1：贪心，找规律，发现尽可能多选择3。

```c++
class Solution {
public:
    int cuttingRope(int n) {
        if (n == 2) return 1;
        if (n == 3) return 2;

        int ans = 1;
        while (n > 4) {
            ans *= 3;
            n -= 3;
        }

        return ans * n;
    }
};
```

## 15. 二进制中1的个数★

编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数

示例 1：

> 输入：n = 11 (控制台输入 00000000000000000000000000001011)
> 输出：3
> 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。

示例 2：

> 输入：n = 128 (控制台输入 00000000000000000000000010000000)
> 输出：1
> 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。

示例 3：

> 输入：n = 4294967293 (控制台输入 11111111111111111111111111111101，部分语言中 n = -3）
> 输出：31
> 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。

- 方法1：使用左移操作循环检查，时间复杂度O(k)，k=32。空间复杂度O(1)。

```c++
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int ret = 0;
        for (int i = 0; i < 32; i++) {
            if (n & (1 << i)) {
                ret++;
            }
        }
        return ret;
    }
};
```

- 方法2：对于`n&(n−1)`，其运算结果把 n 的二进制位中的最低位的 1 变为 0 之后的结果。

- 如6 & (6-1)=4，6=110，4=100。

- 不断让当前的 n 与 n−1 做与运算，直到 n 变为 0 。

  每次运算会使得 n 的最低位的 1 被翻转，因此运算次数就等于 n 的二进制位中 1 的个数。

- 时间复杂度O（log n），最坏情况下就是n的二进制位全部为1，循环logn次，空间复杂度O（1）。

```c++
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int ret = 0;
        while (n) {
            n &= n - 1;
            ret++;
        }
        return ret;
    }
};
```

## 16. 数值的整数次方★

实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。

示例 1：

> 输入：x = 2.00000, n = 10
> 输出：1024.00000

- 方法1：快速幂，记得考虑负数情况。时间复杂度O（logn），空间复杂度O（1）。

```c++
class Solution {
public:
    double myPow(double x, long long n) {
        double ret = 1;

        if (n < 0) {
            n = -n;
            x = 1 / x;
        }

        while (n > 0) {
            if (n & 1) {
                ret *= x;
            }
            n >>= 1;
            x *= x;
        }

        return ret;
    }
};
```



## 17. 打印从1到最大的n位数★

输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。

示例 1:

> 输入: n = 1
> 输出: [1,2,3,4,5,6,7,8,9]



这题要考虑n的范围，如果n是一个非常大的数，即使long long 也会溢出，所以应该用字符串模拟数字，dfs遍历所有可能结果。

- 方法1：字符串模拟+dfs。

```c++
class Solution {
private:
    vector<int> nums;
    string s;
public:
    vector<int> printNumbers(int n) {
        s.resize(n, 0);
        dfs(n, 0);
        return nums;
    }

    void dfs(int end, int now) {
        if (now == end) {
            int i = 0;
            // 打印（存储）时去除开头0
            while (i < s.size() && s[i] == '0') {
                i++;
            }
            if (i != s.size()) {
                // 根据书上的题目，这里我们应该是直接打印字符串
                // cout << s.substr(i) << endl;
                nums.emplace_back(stoi(s.substr(i)));
            }
            return;
        }

        for (int i = 0; i <= 9; i++) {
            s[now] = i + '0';
            dfs(end, now + 1);
        }
    }
};
```

## 18. 删除链表的节点

给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

返回删除后的链表的头节点。

- 原文的意思是，给定一个链表中的节点，我们要删除这个节点。
  - 方法1是从头遍历，获取这个节点的上一个节点，但这需要O(n)时间复杂度。
  - 方法2是将下一个节点的内容复制到该节点，然后删除下一个节点，这样就只需要O(1)时间复杂度了。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* deleteNode(ListNode* head, int val) {
        auto dummyhead = new ListNode(0);
        dummyhead->next = head;
        auto cur = dummyhead;

        while (cur && cur->next) {
            if (cur->next->val == val) {
                cur->next = cur->next->next;
                break;
            }
            cur = cur->next;
        }

        return dummyhead->next;
    }
};
```



## 21. 调整数组顺序使奇数位于偶数前面

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

示例：

> 输入：nums = [1,2,3,4]
> 输出：[1,3,2,4] 
> 注：[3,1,2,4] 也是正确的答案之一。

- 方法1：头尾双指针

```c++
class Solution {
public:
    vector<int> exchange(vector<int>& nums) {
        for (int l = 0, r = nums.size() - 1; l < r;) {
            while (l < nums.size() && (nums[l] & 1) == 1) l++;
            while (r >= 0 && (nums[r] & 1) == 0) r--;
            if (l >= r) break;
            swap(nums[l++], nums[r--]);
        }
        return nums;
    }
};
```

- 方法2：快慢双指针

```c++
class Solution {
public:
    vector<int> exchange(vector<int>& nums) {
        int low = 0, fast = 0;
        while (fast < nums.size()) {
            if (nums[fast] & 1) {
                swap(nums[low], nums[fast]);
                low++;
            }
            fast++;
        }
        return nums;
    }
};
```

> 这题书上还要考虑可拓展性，应该吧判断条件写成函数形式作为参数。



## 22. 链表中倒数第k个节点★

输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。

例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。

- 方法1：快慢指针，**要充分考虑代码鲁棒性**，本题就有3个坑！

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* getKthFromEnd(ListNode* head, int k) {
        // 如果输入的是空指针或者k为0
        if (!head || k == 0) {
            return nullptr;
        }

        auto dummyhead = new ListNode(0);
        dummyhead->next = head;
        
        auto fast = dummyhead;
        for (int i = 0; i < k; i++) {
            fast = fast->next;
            // 如果链表的节点数比k还小
            if (!fast) {
                return nullptr;
            }
        }

        auto slow = dummyhead;
        while (fast) {
            fast = fast->next;
            slow = slow->next;
        }

        return slow;
    }
};
```



## 24. 反转链表★

定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

- 方法1：递归

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (!head || !head->next) {
            return head;
        }
        
        auto node = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;

        return node;
    }
};
```

- 方法2：迭代

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* pre = nullptr;
        ListNode* cur = head;
        ListNode* next = nullptr;

        while (cur) {
            // 存next
            next = cur->next;
            // 操作
            cur->next = pre;
            // pre、cur后移
            pre = cur;
            cur = next;
        }
        
        return pre;
    }
};
```



## 25. 合并两个排序的链表★★

输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。

**示例1：**

```
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
```

- 方法1：迭代

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        auto dummyhead = new ListNode(-1);
        auto pre = dummyhead;

        while (l1 && l2) {
            if (l1->val <= l2->val) {
                pre->next = l1;
                pre = pre->next;
                l1 = l1->next;
            }
            else {
                pre->next = l2;
                pre = pre->next;
                l2 = l2->next;
            }
        }

        if (l1) {
            pre->next = l1;
        }
        if (l2) {
            pre->next = l2;
        }

        return dummyhead->next;
    }
};
```

- 方法2，递归

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if (!l1) {
            return l2;
        }
        else
        if (!l2) {
            return l1;
        }

        if (l1->val <= l2->val) {
            l1->next = mergeTwoLists(l1->next, l2);
            return l1;
        }
        else {
            l2->next = mergeTwoLists(l2->next, l1);
            return l2;
        }
    }
};
```



## 26. 树的子结构★

输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)

B是A的子结构， 即 A中有出现和B相同的结构和节点值。

- 方法1：递归

```c++
class Solution { 
public:
    bool isSubStructure(TreeNode* A, TreeNode* B) {
        if (!A || !B) {
            return false;
        }
        return dfs(A, B) || isSubStructure(A->left, B) || isSubStructure(A->right, B);
    }
    bool dfs(TreeNode* A, TreeNode* B) {
        if (!B) {
            return true;
        }
        if (!A) {
            return false;
        }
        return A->val == B->val && dfs(A->left, B->left) && dfs(A->right, B->right);
    }
};
```



## 27. 二叉树的镜像

请完成一个函数，输入一个二叉树，该函数输出它的镜像。

- 方法1：递归

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* mirrorTree(TreeNode* root) {
        dfs(root);
        return root;
    }

    void dfs(TreeNode* root) {
        if (!root) {
            return;
        }
        auto tmp = root->left;
        root->left = root->right;
        root->right = tmp;
        dfs(root->left);
        dfs(root->right);
    }
};
```

## 28. 对称的二叉树

请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。

- 方法1：

  - 对称二叉树定义： 对于树中 **任意两个对称节点** L 和 R ，一定有：
    - L.val = R.val ：即此两对称节点值相等。
    - L.left.val = R.right.val ：即 L 的 左子节点 和 R 的 右子节点 对称；
    - L.right.val = R.left.val ：即 L 的 右子节点 和 R 的 左子节点 对称。

  或者也可以从遍历的角度出发，一颗对称二叉树的「中右左」遍历和「中左右」遍历（先序遍历）是一样。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        return dfs(root, root);
    }
    bool dfs(TreeNode* root1, TreeNode* root2) {
        if (!root1 && !root2) {
            return true;
        }
        if (!root1 || !root2) {
            return false;
        }
        if (root1->val != root2->val) {
            return false;
        }
        
        return dfs(root1->left, root2->right) && dfs(root1->right, root2->left);
    }
};
```

## 29. 顺时针打印矩阵★

输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。

- 方法1：模拟，写代码前先理清思路

```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> ret;
        if (matrix.empty()) {
            return ret;
        }

        int up = 0, down = matrix.size() - 1;
        int left = 0, right = matrix[0].size() -1;

        while (1) {
            for (int i = left; i <= right; i++) {
                ret.push_back(matrix[up][i]);
            }
            if (++up > down) break;

            for (int i = up; i <= down; i++) {
                ret.push_back(matrix[i][right]);
            }
            if (--right < left) break;

            for (int i = right; i >= left; i--) {
                ret.push_back(matrix[down][i]);
            }
            if (--down < up) break;

            for (int i = down; i >= up; i--) {
                ret.push_back(matrix[i][left]);
            }
            if (++left > right) break;
        }

        return ret;
    }
};
```



## 52. 两个链表的第一个公共节点★★

输入两个链表，找出它们的第一个公共节点。

- 方法1：当链表$ \textit{headA} $和 $\textit{headB} $ 都不为空时，创建两个指针 $\textit{pA}$ 和 $\textit{pB}$，初始时分别指向两个链表的头节点$ \textit{headA}$ 和$ \textit{headB}$，然后将两个指针依次遍历两个链表的每个节点。时间复杂度O（n+m），分别为两个链表的长度，空间复杂度O（1）。

  

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        auto pA = headA;
        auto pB = headB;

        while (pA != pB) {
            pA = pA ? pA->next : headB;
            pB = pB ? pB->next : headA;
        }

        return pA;
    }
};
```

